{
  "language": "Solidity",
  "sources": {
    "contracts/AddressBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./utils/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @author Opyn Team\n * @title AddressBook Module\n */\ncontract AddressBook is Ownable {\n    /// @dev Otoken implementation key\n    bytes32 private constant OTOKEN_IMPL = keccak256(\"OTOKEN_IMPL\");\n    /// @dev OtokenFactory key\n    bytes32 private constant OTOKEN_FACTORY = keccak256(\"OTOKEN_FACTORY\");\n    /// @dev Whitelist key\n    bytes32 private constant WHITELIST = keccak256(\"WHITELIST\");\n    /// @dev Controller key\n    bytes32 private constant CONTROLLER = keccak256(\"CONTROLLER\");\n    /// @dev MarginPool key\n    bytes32 private constant MARGIN_POOL = keccak256(\"MARGIN_POOL\");\n    /// @dev MarginCalculator key\n    bytes32 private constant MARGIN_CALCULATOR = keccak256(\"MARGIN_CALCULATOR\");\n    /// @dev LiquidationManager key\n    bytes32 private constant LIQUIDATION_MANAGER =\n        keccak256(\"LIQUIDATION_MANAGER\");\n    /// @dev Oracle key\n    bytes32 private constant ORACLE = keccak256(\"ORACLE\");\n\n    /// @dev mapping between key and address\n    mapping(bytes32 => address) private addresses;\n\n    /// @notice emits an event when a new proxy is created\n    event ProxyCreated(bytes32 indexed id, address indexed proxy);\n    /// @notice emits an event when a new address is added\n    event AddressAdded(bytes32 indexed id, address indexed add);\n\n    /**\n     * @notice return Otoken implementation address\n     * @return Otoken implementation address\n     */\n    function getOtokenImpl() external view returns (address) {\n        return getAddress(OTOKEN_IMPL);\n    }\n\n    /**\n     * @notice return oTokenFactory address\n     * @return OtokenFactory address\n     */\n    function getOtokenFactory() external view returns (address) {\n        return getAddress(OTOKEN_FACTORY);\n    }\n\n    /**\n     * @notice return Whitelist address\n     * @return Whitelist address\n     */\n    function getWhitelist() external view returns (address) {\n        return getAddress(WHITELIST);\n    }\n\n    /**\n     * @notice return Controller address\n     * @return Controller address\n     */\n    function getController() external view returns (address) {\n        return getAddress(CONTROLLER);\n    }\n\n    /**\n     * @notice return MarginPool address\n     * @return MarginPool address\n     */\n    function getMarginPool() external view returns (address) {\n        return getAddress(MARGIN_POOL);\n    }\n\n    /**\n     * @notice return MarginCalculator address\n     * @return MarginCalculator address\n     */\n    function getMarginCalculator() external view returns (address) {\n        return getAddress(MARGIN_CALCULATOR);\n    }\n\n    /**\n     * @notice return LiquidationManager address\n     * @return LiquidationManager address\n     */\n    function getLiquidationManager() external view returns (address) {\n        return getAddress(LIQUIDATION_MANAGER);\n    }\n\n    /**\n     * @notice return Oracle address\n     * @return Oracle address\n     */\n    function getOracle() external view returns (address) {\n        return getAddress(ORACLE);\n    }\n\n    /**\n     * @notice set Otoken implementation address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenImpl Otoken implementation address\n     */\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\n        setAddress(OTOKEN_IMPL, _otokenImpl);\n    }\n\n    /**\n     * @notice set OtokenFactory address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenFactory OtokenFactory address\n     */\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\n    }\n\n    /**\n     * @notice set Whitelist address\n     * @dev can only be called by the addressbook owner\n     * @param _whitelist Whitelist address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        setAddress(WHITELIST, _whitelist);\n    }\n\n    /**\n     * @notice set Controller address\n     * @dev can only be called by the addressbook owner\n     * @param _controller Controller address\n     */\n    function setController(address _controller) external onlyOwner {\n        updateImpl(CONTROLLER, _controller);\n    }\n\n    /**\n     * @notice set MarginPool address\n     * @dev can only be called by the addressbook owner\n     * @param _marginPool MarginPool address\n     */\n    function setMarginPool(address _marginPool) external onlyOwner {\n        setAddress(MARGIN_POOL, _marginPool);\n    }\n\n    /**\n     * @notice set MarginCalculator address\n     * @dev can only be called by the addressbook owner\n     * @param _marginCalculator MarginCalculator address\n     */\n    function setMarginCalculator(address _marginCalculator) external onlyOwner {\n        setAddress(MARGIN_CALCULATOR, _marginCalculator);\n    }\n\n    /**\n     * @notice set LiquidationManager address\n     * @dev can only be called by the addressbook owner\n     * @param _liquidationManager LiquidationManager address\n     */\n    function setLiquidationManager(address _liquidationManager)\n        external\n        onlyOwner\n    {\n        setAddress(LIQUIDATION_MANAGER, _liquidationManager);\n    }\n\n    /**\n     * @notice set Oracle address\n     * @dev can only be called by the addressbook owner\n     * @param _oracle Oracle address\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        setAddress(ORACLE, _oracle);\n    }\n\n    /**\n     * @notice return an address for specific key\n     * @param _key key address\n     * @return address\n     */\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    /**\n     * @notice set a specific address for a specific key\n     * @dev can only be called by the addressbook owner\n     * @param _key key\n     * @param _address address\n     */\n    function setAddress(bytes32 _key, address _address) public onlyOwner {\n        addresses[_key] = _address;\n\n        emit AddressAdded(_key, _address);\n    }\n\n    /**\n     * @dev function to update the implementation of a specific component of the protocol\n     * @param _id id of the contract to be updated\n     * @param _newAddress address of the new implementation\n     **/\n    function updateImpl(bytes32 _id, address _newAddress) public onlyOwner {\n        address proxyAddress = address(uint160(getAddress(_id)));\n\n        if (proxyAddress == address(0)) {\n            bytes memory params = abi.encodeWithSignature(\n                \"initialize(address,address)\",\n                address(this),\n                owner()\n            );\n            OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy();\n            setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n            proxy.upgradeToAndCall(_newAddress, params);\n        } else {\n            OwnedUpgradeabilityProxy(payable(proxyAddress)).upgradeTo(\n                _newAddress\n            );\n        }\n    }\n}\n"
    },
    "contracts/utils/OwnedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n    /// @dev Storage position of the owner of the contract\n    bytes32 private constant proxyOwnerPosition =\n        keccak256(\"org.zeppelinos.proxy.owner\");\n\n    /**\n     * @dev the constructor sets the original owner of the contract to the sender account.\n     */\n    constructor() {\n        setUpgradeabilityOwner(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner());\n        _;\n    }\n\n    /**\n     * @dev Tells the address of the owner\n     * @return owner the address of the owner\n     */\n    function proxyOwner() public view returns (address owner) {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            owner := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the owner\n     * @param _newProxyOwner address of new proxy owner\n     */\n    function setUpgradeabilityOwner(address _newProxyOwner) internal {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            sstore(position, _newProxyOwner)\n        }\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n        require(_newOwner != address(0));\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n        setUpgradeabilityOwner(_newOwner);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n     * @param _implementation representing the address of the new implementation to be set.\n     */\n    function upgradeTo(address _implementation) public onlyProxyOwner {\n        _upgradeTo(_implementation);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\n     * to initialize whatever is needed through a low level call.\n     * @param _implementation representing the address of the new implementation to be set.\n     * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\n     * signature of the implementation to be called with the needed payload\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        public\n        payable\n        onlyProxyOwner\n    {\n        upgradeTo(_implementation);\n        (bool success, ) = address(this).call{value: msg.value}(_data);\n        require(success);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/utils/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev This event will be emitted every time the implementation gets upgraded\n     * @param implementation representing the address of the upgraded implementation\n     */\n    event Upgraded(address indexed implementation);\n\n    /// @dev Storage position of the address of the current implementation\n    bytes32 private constant implementationPosition =\n        keccak256(\"org.zeppelinos.proxy.implementation\");\n\n    /**\n     * @dev Tells the address of the current implementation\n     * @return impl address of the current implementation\n     */\n    function implementation() public view override returns (address impl) {\n        bytes32 position = implementationPosition;\n        assembly {\n            impl := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the current implementation\n     * @param _newImplementation address representing the new implementation to be set\n     */\n    function setImplementation(address _newImplementation) internal {\n        bytes32 position = implementationPosition;\n        assembly {\n            sstore(position, _newImplementation)\n        }\n    }\n\n    /**\n     * @dev Upgrades the implementation address\n     * @param _newImplementation representing the address of the new implementation to be set\n     */\n    function _upgradeTo(address _newImplementation) internal {\n        address currentImplementation = implementation();\n        require(currentImplementation != _newImplementation);\n        setImplementation(_newImplementation);\n        emit Upgraded(_newImplementation);\n    }\n}\n"
    },
    "contracts/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\nabstract contract Proxy {\n    /**\n     * @dev Tells the address of the implementation where every call will be delegated.\n     * @return address of the implementation to which it will be delegated\n     */\n    function implementation() public view virtual returns (address);\n\n    receive() external payable {\n        _fallback();\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n     * This function will return whatever the implementation call returns\n     */\n    function _fallback() internal {\n        address _impl = implementation();\n        require(_impl != address(0));\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/upgrades/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev Contract constructor.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view override returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/upgrades/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Receive function.\n     * Implemented entirely in `_fallback`.\n     */\n    receive() external payable {\n        // _fallback();\n    }\n\n    /**\n     * @return The Address of the implementation.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param implementation Address to delegate.\n     */\n    function _delegate(address implementation) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal virtual {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"
    },
    "contracts/upgrades/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n     * Contract constructor.\n     * @param _logic address of the initial implementation.\n     * @param admin_ Address of the proxy administrator.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable UpgradeabilityProxy(_logic, _data) {\n        assert(\n            ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier to check whether the `msg.sender` is the admin.\n     * If it is, it will run the function. Otherwise, it will delegate the call\n     * to the implementation.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @return adminAddress The address of the proxy admin.\n     */\n    function admin() external ifAdmin returns (address adminAddress) {\n        return _admin();\n    }\n\n    /**\n     * @return implementationAddress The address of the implementation.\n     */\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementationAddress)\n    {\n        return _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(\n            newAdmin != address(0),\n            \"Cannot change the admin of a proxy to the zero address\"\n        );\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @return adm The admin slot.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the proxy admin.\n     * @param newAdmin Address of the new proxy admin.\n     */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal virtual override {\n        require(\n            msg.sender != _admin(),\n            \"Cannot call fallback function from the proxy admin\"\n        );\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/utils/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../interfaces/IERC20Detailed.sol\";\r\nimport \"../interfaces/GammaInterface.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../SwapStorage.sol\";\r\n\r\ncontract Swap is\r\n    ISwap,\r\n    ReentrancyGuardUpgradeable,\r\n    OwnableUpgradeable,\r\n    SwapStorage\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public immutable DOMAIN_CHAIN_ID;\r\n\r\n    bytes32 public constant DOMAIN_TYPEHASH =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"EIP712Domain(\",\r\n                \"string name,\",\r\n                \"string version,\",\r\n                \"uint256 chainId,\",\r\n                \"address verifyingContract\",\r\n                \")\"\r\n            )\r\n        );\r\n\r\n    bytes32 public constant BID_TYPEHASH =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"Bid(\",\r\n                \"uint256 swapId,\",\r\n                \"uint256 nonce,\",\r\n                \"address signerWallet,\",\r\n                \"uint256 sellAmount,\",\r\n                \"uint256 buyAmount,\",\r\n                \"address referrer\",\r\n                \")\"\r\n            )\r\n        );\r\n\r\n    uint256 public constant MAX_PERCENTAGE = 1000000;\r\n    uint256 public constant MAX_FEE = 125000; // 12.5%\r\n    uint256 internal constant MAX_ERROR_COUNT = 10;\r\n    uint256 internal constant OTOKEN_DECIMALS = 8;\r\n\r\n    /************************************************\r\n     *  CONSTRUCTOR\r\n     ***********************************************/\r\n\r\n    constructor() {\r\n        uint256 currentChainId = block.chainid;\r\n        DOMAIN_CHAIN_ID = currentChainId;\r\n    }\r\n\r\n    /************************************************\r\n     *  INITIALIZATION\r\n     ***********************************************/\r\n\r\n    function initialize(\r\n        string memory _domainName,\r\n        string memory _domainVersion,\r\n        address _owner\r\n    ) external initializer {\r\n        require(bytes(_domainName).length > 0, \"!_domainName\");\r\n        require(bytes(_domainVersion).length > 0, \"!_domainVersion\");\r\n        require(_owner != address(0), \"!_owner\");\r\n\r\n        __ReentrancyGuard_init();\r\n        __Ownable_init();\r\n        transferOwnership(_owner);\r\n\r\n        DOMAIN_NAME = keccak256(bytes(_domainName));\r\n        DOMAIN_VERSION = keccak256(bytes(_domainVersion));\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                DOMAIN_NAME,\r\n                DOMAIN_VERSION,\r\n                DOMAIN_CHAIN_ID,\r\n                this\r\n            )\r\n        );\r\n    }\r\n\r\n    /************************************************\r\n     *  SETTER\r\n     ***********************************************/\r\n\r\n    /**\r\n     * @notice Sets the referral fee for a specific referrer\r\n     * @param referrer is the address of the referrer\r\n     * @param fee is the fee in percent in 2 decimals\r\n     */\r\n    function setFee(address referrer, uint256 fee) external onlyOwner {\r\n        require(referrer != address(0), \"Referrer cannot be the zero address\");\r\n        require(fee < MAX_FEE, \"Fee exceeds maximum\");\r\n\r\n        referralFees[referrer] = fee;\r\n\r\n        emit SetFee(referrer, fee);\r\n    }\r\n\r\n    /************************************************\r\n     *  OFFER CREATION AND SETTLEMENT\r\n     ***********************************************/\r\n\r\n    /**\r\n     * @notice Create a new offer available for swap\r\n     * @param oToken token offered by seller\r\n     * @param biddingToken token asked by seller\r\n     * @param minPrice minimum price of oToken denominated in biddingToken\r\n     * @param minBidSize minimum amount of oToken requested in a single bid\r\n     * @param totalSize amount of oToken offered by seller\r\n     */\r\n    function createOffer(\r\n        address oToken,\r\n        address biddingToken,\r\n        uint96 minPrice,\r\n        uint96 minBidSize,\r\n        uint128 totalSize\r\n    ) external override returns (uint256 swapId) {\r\n        require(oToken != address(0), \"oToken cannot be the zero address\");\r\n        require(\r\n            biddingToken != address(0),\r\n            \"BiddingToken cannot be the zero address\"\r\n        );\r\n        require(minPrice > 0, \"MinPrice must be larger than zero\");\r\n        require(minBidSize > 0, \"MinBidSize must be larger than zero\");\r\n        require(minBidSize <= totalSize, \"MinBidSize exceeds total size\");\r\n\r\n        if (IOtoken(oToken).isPut()) {\r\n            require(\r\n                priceFeeds[IOtoken(oToken).underlyingAsset()] != address(0),\r\n                \"No price feed set\"\r\n            );\r\n        }\r\n\r\n        // Check seller allowance\r\n        uint256 sellerAllowance = IERC20(oToken).allowance(\r\n            msg.sender,\r\n            address(this)\r\n        );\r\n        require(sellerAllowance >= totalSize, \"Seller allowance low\");\r\n\r\n        // Check seller balance\r\n        uint256 sellerBalance = IERC20(oToken).balanceOf(msg.sender);\r\n        require(sellerBalance >= totalSize, \"Seller balance low\");\r\n\r\n        offersCounter += 1;\r\n\r\n        swapId = offersCounter;\r\n\r\n        swapOffers[swapId].seller = msg.sender;\r\n        swapOffers[swapId].oToken = oToken;\r\n        swapOffers[swapId].biddingToken = biddingToken;\r\n        swapOffers[swapId].minBidSize = minBidSize;\r\n        swapOffers[swapId].minPrice = minPrice;\r\n        swapOffers[swapId].totalSize = totalSize;\r\n        swapOffers[swapId].availableSize = totalSize;\r\n        // We warm the storage slot with 1 wei so we avoid a cold SSTORE\r\n        swapOffers[swapId].totalSales = 1;\r\n\r\n        emit NewOffer(\r\n            swapId,\r\n            msg.sender,\r\n            oToken,\r\n            biddingToken,\r\n            minPrice,\r\n            minBidSize,\r\n            totalSize\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Settles the swap offering by iterating through the bids\r\n     * @param swapId unique identifier of the swap offer\r\n     * @param bids bids for swaps\r\n     */\r\n    function settleOffer(uint256 swapId, Bid[] calldata bids)\r\n        external\r\n        override\r\n        nonReentrant\r\n    {\r\n        Offer storage offer = swapOffers[swapId];\r\n\r\n        address seller = offer.seller;\r\n        require(\r\n            seller == msg.sender,\r\n            \"Only seller can settle or offer doesn't exist\"\r\n        );\r\n        require(offer.availableSize > 0, \"Offer fully settled\");\r\n\r\n        uint256 totalSales;\r\n        OfferDetails memory offerDetails;\r\n        offerDetails.seller = seller;\r\n        offerDetails.oToken = offer.oToken;\r\n        offerDetails.biddingToken = offer.biddingToken;\r\n        offerDetails.minPrice = offer.minPrice;\r\n        offerDetails.minBidSize = offer.minBidSize;\r\n\r\n        for (uint256 i = 0; i < bids.length; i++) {\r\n            require(\r\n                swapId == bids[i].swapId,\r\n                \"Offer and bid swapId mismatched\"\r\n            );\r\n\r\n            _swap(offerDetails, offer, bids[i]);\r\n            totalSales += bids[i].sellAmount;\r\n        }\r\n\r\n        bool fullySettled = offer.availableSize == 0;\r\n\r\n        // Deduct the initial 1 wei offset if offer is fully settled\r\n        offer.totalSales += totalSales - (fullySettled ? 1 : 0);\r\n\r\n        if (fullySettled) {\r\n            offer.seller = address(0);\r\n            offer.oToken = address(0);\r\n            offer.biddingToken = address(0);\r\n            offer.minBidSize = 0;\r\n            offer.minPrice = 0;\r\n\r\n            emit SettleOffer(swapId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Authorize a signer\r\n     * @param signer address Wallet of the signer to authorize\r\n     * @dev Emits an Authorize event\r\n     */\r\n    function authorize(address signer) external override {\r\n        require(signer != address(0), \"SIGNER_INVALID\");\r\n        authorized[msg.sender] = signer;\r\n        emit Authorize(signer, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke the signer\r\n     * @dev Emits a Revoke event\r\n     */\r\n    function revoke() external override {\r\n        address tmp = authorized[msg.sender];\r\n        delete authorized[msg.sender];\r\n        emit Revoke(tmp, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel one or more nonces\r\n     * @dev Cancelled nonces are marked as used\r\n     * @dev Emits a Cancel event\r\n     * @dev Out of gas may occur in arrays of length > 400\r\n     * @param nonces uint256[] List of nonces to cancel\r\n     */\r\n    function cancelNonce(uint256[] calldata nonces) external override {\r\n        for (uint256 i = 0; i < nonces.length; i++) {\r\n            uint256 nonce = nonces[i];\r\n            if (_markNonceAsUsed(msg.sender, nonce)) {\r\n                emit Cancel(nonce, msg.sender);\r\n            }\r\n        }\r\n    }\r\n\r\n    /************************************************\r\n     *  PUBLIC VIEW FUNCTIONS\r\n     ***********************************************/\r\n\r\n    /**\r\n     * @notice Validates Swap bid for any potential errors\r\n     * @param bid Bid struct containing bid details\r\n     * @return tuple of error count and bytes32[] memory array of error messages\r\n     */\r\n    function check(Bid calldata bid)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256, bytes32[] memory)\r\n    {\r\n        Offer memory offer = swapOffers[bid.swapId];\r\n        require(offer.seller != address(0), \"Offer does not exist\");\r\n\r\n        bytes32[] memory errors = new bytes32[](MAX_ERROR_COUNT);\r\n\r\n        uint256 errCount;\r\n\r\n        // Check signature\r\n        address signatory = _getSignatory(bid);\r\n\r\n        if (signatory == address(0)) {\r\n            errors[errCount] = \"SIGNATURE_INVALID\";\r\n            errCount++;\r\n        }\r\n\r\n        if (\r\n            bid.signerWallet != signatory &&\r\n            authorized[bid.signerWallet] != signatory\r\n        ) {\r\n            errors[errCount] = \"UNAUTHORIZED\";\r\n            errCount++;\r\n        }\r\n\r\n        // Check nonce\r\n        if (nonceUsed(signatory, bid.nonce)) {\r\n            errors[errCount] = \"NONCE_ALREADY_USED\";\r\n            errCount++;\r\n        }\r\n\r\n        // Check bid size\r\n        if (bid.buyAmount < offer.minBidSize) {\r\n            errors[errCount] = \"BID_TOO_SMALL\";\r\n            errCount++;\r\n        }\r\n        if (bid.buyAmount > offer.availableSize) {\r\n            errors[errCount] = \"BID_EXCEED_AVAILABLE_SIZE\";\r\n            errCount++;\r\n        }\r\n\r\n        // Check bid price\r\n        uint256 bidPrice = (bid.sellAmount * 10**OTOKEN_DECIMALS) /\r\n            bid.buyAmount;\r\n        if (bidPrice < offer.minPrice) {\r\n            errors[errCount] = \"PRICE_TOO_LOW\";\r\n            errCount++;\r\n        }\r\n\r\n        // Check signer allowance\r\n        uint256 signerAllowance = IERC20(offer.biddingToken).allowance(\r\n            bid.signerWallet,\r\n            address(this)\r\n        );\r\n        if (signerAllowance < bid.sellAmount) {\r\n            errors[errCount] = \"SIGNER_ALLOWANCE_LOW\";\r\n            errCount++;\r\n        }\r\n\r\n        // Check signer balance\r\n        uint256 signerBalance = IERC20(offer.biddingToken).balanceOf(\r\n            bid.signerWallet\r\n        );\r\n        if (signerBalance < bid.sellAmount) {\r\n            errors[errCount] = \"SIGNER_BALANCE_LOW\";\r\n            errCount++;\r\n        }\r\n\r\n        return (errCount, errors);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the average settlement price for a swap offer\r\n     * @param swapId unique identifier of the swap offer\r\n     */\r\n    function averagePriceForOffer(uint256 swapId)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        Offer storage offer = swapOffers[swapId];\r\n        require(offer.totalSize != 0, \"Offer does not exist\");\r\n\r\n        uint256 availableSize = offer.availableSize;\r\n\r\n        // Deduct the initial 1 wei offset if offer is not fully settled\r\n        uint256 adjustment = availableSize != 0 ? 1 : 0;\r\n\r\n        return\r\n            ((offer.totalSales - adjustment) * (10**8)) /\r\n            (offer.totalSize - availableSize);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the nonce has been used\r\n     * @param signer address Address of the signer\r\n     * @param nonce uint256 Nonce being checked\r\n     */\r\n    function nonceUsed(address signer, uint256 nonce)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        uint256 groupKey = nonce / 256;\r\n        uint256 indexInGroup = nonce % 256;\r\n        return (_nonceGroups[signer][groupKey] >> indexInGroup) & 1 == 1;\r\n    }\r\n\r\n    /************************************************\r\n     *  INTERNAL FUNCTIONS\r\n     ***********************************************/\r\n\r\n    /**\r\n     * @notice Swap Atomic ERC20 Swap\r\n     * @param details Details of offering\r\n     * @param offer Offer struct containing offer details\r\n     * @param bid Bid struct containing bid details\r\n     */\r\n    function _swap(\r\n        OfferDetails memory details,\r\n        Offer storage offer,\r\n        Bid calldata bid\r\n    ) internal {\r\n        require(DOMAIN_CHAIN_ID == block.chainid, \"CHAIN_ID_CHANGED\");\r\n\r\n        address signatory = _getSignatory(bid);\r\n\r\n        require(signatory != address(0), \"SIGNATURE_INVALID\");\r\n\r\n        if (bid.signerWallet != signatory) {\r\n            require(authorized[bid.signerWallet] == signatory, \"UNAUTHORIZED\");\r\n        }\r\n\r\n        require(_markNonceAsUsed(signatory, bid.nonce), \"NONCE_ALREADY_USED\");\r\n        require(\r\n            bid.buyAmount <= offer.availableSize,\r\n            \"BID_EXCEED_AVAILABLE_SIZE\"\r\n        );\r\n        require(bid.buyAmount >= details.minBidSize, \"BID_TOO_SMALL\");\r\n\r\n        // Ensure min. price is met\r\n        uint256 bidPrice = (bid.sellAmount * 10**OTOKEN_DECIMALS) /\r\n            bid.buyAmount;\r\n        require(bidPrice >= details.minPrice, \"PRICE_TOO_LOW\");\r\n\r\n        // don't have to do a uint128 check because we already check\r\n        // that bid.buyAmount <= offer.availableSize\r\n        offer.availableSize -= uint128(bid.buyAmount);\r\n\r\n        // Transfer token from sender to signer\r\n        IERC20(details.oToken).safeTransferFrom(\r\n            details.seller,\r\n            bid.signerWallet,\r\n            bid.buyAmount\r\n        );\r\n\r\n        // Transfer to referrer if any\r\n        uint256 feeAmount;\r\n        if (bid.referrer != address(0)) {\r\n            uint256 feePercent = referralFees[bid.referrer];\r\n\r\n            if (feePercent > 0) {\r\n                feeAmount = calculateReferralFee(\r\n                    details.oToken,\r\n                    feePercent,\r\n                    bid.buyAmount,\r\n                    bid.sellAmount\r\n                );\r\n\r\n                IERC20(details.biddingToken).safeTransferFrom(\r\n                    bid.signerWallet,\r\n                    bid.referrer,\r\n                    feeAmount\r\n                );\r\n            }\r\n        }\r\n\r\n        // Transfer token from signer to recipient\r\n        IERC20(details.biddingToken).safeTransferFrom(\r\n            bid.signerWallet,\r\n            details.seller,\r\n            bid.sellAmount - feeAmount\r\n        );\r\n\r\n        // Emit a Swap event\r\n        emit Swap(\r\n            bid.swapId,\r\n            bid.nonce,\r\n            bid.signerWallet,\r\n            bid.sellAmount,\r\n            bid.buyAmount,\r\n            bid.referrer,\r\n            feeAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Marks a nonce as used for the given signer\r\n     * @param signer address Address of the signer for which to mark the nonce as used\r\n     * @param nonce uint256 Nonce to be marked as used\r\n     * @return bool True if the nonce was not marked as used already\r\n     */\r\n    function _markNonceAsUsed(address signer, uint256 nonce)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 groupKey = nonce / 256;\r\n        uint256 indexInGroup = nonce % 256;\r\n        uint256 group = _nonceGroups[signer][groupKey];\r\n\r\n        // If it is already used, return false\r\n        if ((group >> indexInGroup) & 1 == 1) {\r\n            return false;\r\n        }\r\n\r\n        _nonceGroups[signer][groupKey] = group | (uint256(1) << indexInGroup);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Recover the signatory from a signature\r\n     * @param bid Bid struct containing bid details\r\n     */\r\n    function _getSignatory(Bid calldata bid) internal view returns (address) {\r\n        return\r\n            ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR,\r\n                        keccak256(\r\n                            abi.encode(\r\n                                BID_TYPEHASH,\r\n                                bid.swapId,\r\n                                bid.nonce,\r\n                                bid.signerWallet,\r\n                                bid.sellAmount,\r\n                                bid.buyAmount,\r\n                                bid.referrer\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                bid.v,\r\n                bid.r,\r\n                bid.s\r\n            );\r\n    }\r\n\r\n    /**\r\n     * This function assumes that all CALL premiums are denominated in the Offer.biddingToken\r\n     * This could easily change if we enabled Paradigm for Treasury - Calls are sold for USDC.\r\n     * It assumes that all PUT premiums are denominated in USDC.\r\n     */\r\n    function calculateReferralFee(\r\n        address otokenAddress,\r\n        uint256 feePercent,\r\n        uint256 numContracts,\r\n        uint256 premium\r\n    ) public view returns (uint256) {\r\n        IOtoken otoken = IOtoken(otokenAddress);\r\n        uint256 maxFee = (premium * MAX_FEE) / MAX_PERCENTAGE;\r\n        uint256 fee;\r\n\r\n        if (otoken.isPut()) {\r\n            uint256 marketPrice = getMarketPrice(otoken.underlyingAsset());\r\n            // both numContracts and marketPrice are 10**8\r\n            // then you scale it down to 10**6 because of USDC\r\n            uint256 notional = (numContracts * marketPrice) / 10**10;\r\n            fee = (notional * feePercent) / MAX_PERCENTAGE;\r\n        } else {\r\n            IERC20Detailed underlying = IERC20Detailed(\r\n                otoken.underlyingAsset()\r\n            );\r\n            uint256 underlyingDecimals = underlying.decimals();\r\n            uint256 numContractsInUnderlying;\r\n            if (underlyingDecimals < 8) {\r\n                numContractsInUnderlying =\r\n                    numContracts /\r\n                    10**(underlyingDecimals - 8);\r\n            } else {\r\n                numContractsInUnderlying =\r\n                    numContracts *\r\n                    10**(underlyingDecimals - 8);\r\n            }\r\n            fee = (numContractsInUnderlying * feePercent) / MAX_PERCENTAGE;\r\n        }\r\n\r\n        if (fee > maxFee) {\r\n            return maxFee;\r\n        }\r\n        return fee;\r\n    }\r\n\r\n    function getMarketPrice(address asset) public view returns (uint256) {\r\n        address feed = priceFeeds[asset];\r\n        require(feed != address(0), \"NO_PRICE_FEED_SET\");\r\n        (\r\n            ,\r\n            /*uint80 roundID*/\r\n            int256 price, /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/\r\n            ,\r\n            ,\r\n\r\n        ) = AggregatorV3Interface(feed).latestRoundData();\r\n\r\n        require(price > 0, \"INVALID_PRICE_FEED\");\r\n\r\n        return uint256(price);\r\n    }\r\n\r\n    function setPriceFeed(address asset, address aggregator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        priceFeeds[asset] = aggregator;\r\n        emit SetPriceFeed(asset, aggregator);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string calldata);\n\n    function name() external view returns (string calldata);\n}\n"
    },
    "contracts/interfaces/GammaInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary GammaTypes {\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\n        // in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n}\n\ninterface IOtoken {\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n}\n\ninterface IOtokenFactory {\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address);\n\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n}\n\ninterface IController {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call,\n        Liquidate\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets\n        // but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    function getPayout(address _otoken, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function operate(ActionArgs[] calldata _actions) external;\n\n    function getAccountVaultCounter(address owner)\n        external\n        view\n        returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function getVault(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (GammaTypes.Vault memory);\n\n    function getProceed(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (uint256);\n\n    function isSettlementAllowed(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool);\n}\n\ninterface IOracle {\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function updateAssetPricer(address _asset, address _pricer) external;\n\n    function getPrice(address _asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ISwap {\n    struct Offer {\n        // 32 byte slot 1, partial fill\n        // Seller wallet address\n        address seller;\n        // 32 byte slot 2\n        // Addess of oToken\n        address oToken;\n        // Price per oToken denominated in biddingToken\n        uint96 minPrice;\n        // 32 byte slot 3\n        // ERC20 Token to bid for oToken\n        address biddingToken;\n        // Minimum oToken amount acceptable for a single bid\n        uint96 minBidSize;\n        // 32 byte slot 4\n        // Total available oToken amount\n        uint128 totalSize;\n        // Remaining available oToken amount\n        // This figure is updated after each successfull swap\n        uint128 availableSize;\n        // 32 byte slot 5\n        // Amount of biddingToken received\n        // This figure is updated after each successfull swap\n        uint256 totalSales;\n    }\n\n    struct Bid {\n        // ID assigned to offers\n        uint256 swapId;\n        // Number only used once for each wallet\n        uint256 nonce;\n        // Signer wallet address\n        address signerWallet;\n        // Amount of biddingToken offered by signer\n        uint256 sellAmount;\n        // Amount of oToken requested by signer\n        uint256 buyAmount;\n        // Referrer wallet address\n        address referrer;\n        // Signature recovery id\n        uint8 v;\n        // r portion of the ECSDA signature\n        bytes32 r;\n        // s portion of the ECSDA signature\n        bytes32 s;\n    }\n\n    struct OfferDetails {\n        // Seller wallet address\n        address seller;\n        // Addess of oToken\n        address oToken;\n        // Price per oToken denominated in biddingToken\n        uint256 minPrice;\n        // ERC20 Token to bid for oToken\n        address biddingToken;\n        // Minimum oToken amount acceptable for a single bid\n        uint256 minBidSize;\n    }\n\n    event Swap(\n        uint256 indexed swapId,\n        uint256 nonce,\n        address indexed signerWallet,\n        uint256 signerAmount,\n        uint256 sellerAmount,\n        address referrer,\n        uint256 feeAmount\n    );\n\n    event NewOffer(\n        uint256 swapId,\n        address seller,\n        address oToken,\n        address biddingToken,\n        uint256 minPrice,\n        uint256 minBidSize,\n        uint256 totalSize\n    );\n\n    event SetFee(address referrer, uint256 fee);\n\n    event SetPriceFeed(address asset, address aggregator);\n\n    event SettleOffer(uint256 swapId);\n\n    event Cancel(uint256 indexed nonce, address indexed signerWallet);\n\n    event Authorize(address indexed signer, address indexed signerWallet);\n\n    event Revoke(address indexed signer, address indexed signerWallet);\n\n    function createOffer(\n        address oToken,\n        address biddingToken,\n        uint96 minPrice,\n        uint96 minBidSize,\n        uint128 totalSize\n    ) external returns (uint256 swapId);\n\n    function settleOffer(uint256 swapId, Bid[] calldata bids) external;\n\n    function cancelNonce(uint256[] calldata nonces) external;\n\n    function check(Bid calldata bid)\n        external\n        view\n        returns (uint256, bytes32[] memory);\n\n    function averagePriceForOffer(uint256 swapId)\n        external\n        view\n        returns (uint256);\n\n    function authorize(address sender) external;\n\n    function revoke() external;\n\n    function nonceUsed(address, uint256) external view returns (bool);\n}\n"
    },
    "contracts/SwapStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/ISwap.sol\";\n\nabstract contract SwapStorageV1 {\n    // Keccak256 of domain name for signature verification\n    bytes32 public DOMAIN_NAME;\n    // Keccak256 of domain version for signature verification\n    bytes32 public DOMAIN_VERSION;\n    // Keccak256 of abi-encoded domain parameters for signature verification\n    bytes32 public DOMAIN_SEPARATOR;\n\n    // Counter to keep track number of offers\n    uint256 public offersCounter;\n    // Mapping of swap offer details for a given swapId\n    mapping(uint256 => ISwap.Offer) public swapOffers;\n    // Mapping of referral fees for a given address, 1000000 = 100%\n    mapping(address => uint256) public referralFees;\n    // Mapping of authorized delegate for a given address\n    mapping(address => address) public authorized;\n    /**\n     * @notice Double mapping of signers to nonce groups to nonce states\n     * @dev The nonce group is computed as nonce / 256, so each group of 256 sequential nonces uses the same key\n     * @dev The nonce states are encoded as 256 bits, for each nonce in the group 0 means available and 1 means used\n     */\n    mapping(address => mapping(uint256 => uint256)) internal _nonceGroups;\n}\n\nabstract contract SwapStorageV2 {\n    // Price feed for looking up value of asset\n    mapping(address => address) public priceFeeds;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of SwapStorage\n// e.g. SwapStorage<versionNumber>, so finally it would look like\n// contract SwapStorage is SwapStorageV1, SwapStorageV2\nabstract contract SwapStorage is SwapStorageV1, SwapStorageV2 {\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/RibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./libs/VaultLifecycle.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./libs/ShareMath.sol\";\nimport \"./libs/Vault.sol\";\n\ncontract RibbonVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the options sold and the timelocked option\n    Vault.OptionState public optionState;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextOption and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\n    uint256[30] private ____gap;\n\n    // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\n    // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaVaultStorage\n    // or RibbonDeltaVaultStorage instead. Read this documentation to learn more:\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public immutable USDC;\n\n    /// @notice Deprecated: 15 minute timelock between commitAndClose and rollToNexOption.\n    uint256 public constant DELAY = 0;\n\n    /// @notice 7 day period between each options sale.\n    uint256 public constant PERIOD = 7 days;\n\n    // Number of weeks per year = 52.142857 weeks * FEE_MULTIPLIER = 52142857\n    // Dividing by weeks per year requ`ires doing num.mul(FEE_MULTIPLIER).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyInitializerParams(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _performanceFee,\n            _managementFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        keeper = _keeper;\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee =\n            (_managementFee * Vault.FEE_MULTIPLIER) /\n            WEEKS_PER_YEAR;\n        vaultParams = _vaultParams;\n\n        uint256 assetBalance = IERC20(vaultParams.asset).balanceOf(\n            address(this)\n        );\n        vaultState.lastLockedAmount = assetBalance.toUint104();\n\n        vaultState.round = 1;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"!newKeeper\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        require(newFeeRecipient != feeRecipient, \"Must be new feeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(\n            newManagementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid management fee\"\n        );\n\n        // We are dividing annualized management fee by num weeks in a year\n        uint256 tmpManagementFee = (newManagementFee * Vault.FEE_MULTIPLIER) /\n            WEEKS_PER_YEAR;\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        managementFee = tmpManagementFee;\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(\n            newPerformanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid performance fee\"\n        );\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = newCap.toUint104();\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance() + amount;\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[depositReceipt.round],\n            vaultParams.decimals\n        );\n\n        uint256 depositAmount = amount;\n\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount) + amount;\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: currentRound.toUint16(),\n            amount: depositAmount.toUint104(),\n            unredeemedShares: unredeemedShares.toUint128()\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending) + amount;\n        vaultState.totalPending = newTotalPending.toUint128();\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function _initiateWithdraw(uint256 numShares) internal {\n        require(numShares > 0, \"!numShares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool withdrawalIsSameRound = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n\n        uint256 existingShares = uint256(withdrawal.shares);\n\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares + numShares;\n        } else {\n            require(existingShares == 0, \"Existing withdraw\");\n            withdrawalShares = numShares;\n            withdrawals[msg.sender].round = currentRound.toUint16();\n        }\n\n        withdrawals[msg.sender].shares = withdrawalShares.toUint128();\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @return withdrawAmount the current withdrawal amount\n     */\n    function _completeWithdraw() internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = (uint256(\n            vaultState.queuedWithdrawShares\n        ) - withdrawalShares)\n        .toUint128();\n\n        uint256 withdrawAmount = ShareMath.sharesToAsset(\n            withdrawalShares,\n            roundPricePerShare[withdrawalRound],\n            vaultParams.decimals\n        );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[\n            msg.sender\n        ];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            currentRound,\n            roundPricePerShare[depositReceipt.round],\n            vaultParams.decimals\n        );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"Exceeds available\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        depositReceipts[msg.sender].unredeemedShares = (unredeemedShares -\n            numShares)\n        .toUint128();\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds > 0, \"!numRounds\");\n\n        uint256 _round = vaultState.round;\n        for (uint256 i = 0; i < numRounds; i++) {\n            uint256 index = _round + i;\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = ShareMath.PLACEHOLDER_UINT;\n        }\n    }\n\n    /**\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @param lastQueuedWithdrawAmount is old queued withdraw amount\n     * @param currentQueuedWithdrawShares is the queued withdraw shares for the current round\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     * @return queuedWithdrawAmount is the new queued withdraw amount for this round\n     */\n    function _rollToNextOption(\n        uint256 lastQueuedWithdrawAmount,\n        uint256 currentQueuedWithdrawShares\n    )\n        internal\n        returns (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        )\n    {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        // address recipient = feeRecipient;\n        uint256 mintShares;\n        uint256 performanceFeeInAsset;\n        uint256 totalVaultFee;\n        uint256 newPricePerShare;\n        {\n            (\n                lockedBalance,\n                queuedWithdrawAmount,\n                newPricePerShare,\n                mintShares,\n                performanceFeeInAsset,\n                totalVaultFee\n            ) = VaultLifecycle.rollover(\n                vaultState,\n                VaultLifecycle.RolloverParams(\n                    vaultParams.decimals,\n                    IERC20(vaultParams.asset).balanceOf(address(this)),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    performanceFee,\n                    managementFee,\n                    currentQueuedWithdrawShares\n                )\n            );\n\n            optionState.currentOption = newOption;\n            optionState.nextOption = address(0);\n\n            // Finalize the pricePerShare at the end of the round\n            roundPricePerShare[vaultState.round] = newPricePerShare;\n\n            emit CollectVaultFees(\n                performanceFeeInAsset,\n                totalVaultFee,\n                vaultState.round,\n                feeRecipient\n            );\n\n            vaultState.totalPending = 0;\n            vaultState.round++;\n        }\n\n        _mint(address(this), mintShares);\n\n        if (totalVaultFee > 0) {\n            transferAsset(payable(feeRecipient), totalVaultFee);\n        }\n\n        return (newOption, lockedBalance, queuedWithdrawAmount);\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(amount);\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare = ShareMath.pricePerShare(\n            totalSupply(),\n            totalBalance(),\n            vaultState.totalPending,\n            _decimals\n        );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount + heldByVault;\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            vaultState.round,\n            roundPricePerShare[depositReceipt.round],\n            vaultParams.decimals\n        );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount) +\n            IERC20(vaultParams.asset).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n}\n"
    },
    "contracts/libs/VaultLifecycle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/GammaInterface.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/IGnosisAuction.sol\";\nimport \"../interfaces/IOptionsPurchaseQueue.sol\";\nimport \"../interfaces/IRibbon.sol\";\nimport \"./SupportsNonCompliantERC20.sol\";\nimport \"./GnosisAuction.sol\";\nimport \"./ShareMath.sol\";\nimport \"./Vault.sol\";\n\nlibrary VaultLifecycle {\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverrideRound;\n        uint256 overriddenStrikePrice;\n        address strikeSelection;\n        address optionsPremiumPricer;\n        uint256 premiumDiscount;\n    }\n\n    /// @notice Default maximum option allocation for the queue (50%)\n    uint256 internal constant QUEUE_OPTION_ALLOCATION = 5000;\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return otokenAddress is the address of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitAndClose(\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry = getNextExpiry(closeParams.currentOption);\n\n        IStrikeSelection selection = IStrikeSelection(\n            closeParams.strikeSelection\n        );\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            vaultParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        return (otokenAddress, strikePrice, delta);\n    }\n\n    /**\n     * @notice Verify the otoken has the correct parameters to prevent vulnerability to opyn contract changes\n     * @param otokenAddress is the address of the otoken\n     * @param vaultParams is the struct with vault general data\n     * @param collateralAsset is the address of the collateral asset\n     * @param USDC is the address of usdc\n     * @param delay is the delay between commitAndClose and rollToNextOption\n     */\n    function verifyOtoken(\n        address otokenAddress,\n        Vault.VaultParams storage vaultParams,\n        address collateralAsset,\n        address USDC,\n        uint256 delay\n    ) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        require(otoken.isPut() == vaultParams.isPut, \"Type mismatch\");\n        require(\n            otoken.underlyingAsset() == vaultParams.underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(\n            otoken.collateralAsset() == collateralAsset,\n            \"Wrong collateralAsset\"\n        );\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp + delay;\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    /**\n     * @param decimals is the decimals of the asset\n     * @param totalBalance is the vaults total balance of the asset\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\n     * @param lastQueuedWithdrawAmount is the total amount queued for withdrawals\n     * @param performanceFee is the perf fee percent to charge on premiums\n     * @param managementFee is the management fee percent to charge on the AUM\n     * @param currentQueuedWithdrawShares is amount of queued withdrawals from the current round\n     */\n    struct RolloverParams {\n        uint256 decimals;\n        uint256 totalBalance;\n        uint256 currentShareSupply;\n        uint256 lastQueuedWithdrawAmount;\n        uint256 performanceFee;\n        uint256 managementFee;\n        uint256 currentQueuedWithdrawShares;\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\n     * @param params is the rollover parameters passed to compute the next state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     * @return performanceFeeInAsset is the performance fee charged by vault\n     * @return totalVaultFee is the total amount of fee charged by vault\n     */\n    function rollover(\n        Vault.VaultState storage vaultState,\n        RolloverParams calldata params\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        uint256 currentBalance = params.totalBalance;\n        uint256 pendingAmount = vaultState.totalPending;\n        // Total amount of queued withdrawal shares from previous rounds (doesn't include the current round)\n        uint256 lastQueuedWithdrawShares = vaultState.queuedWithdrawShares;\n\n        // Deduct older queued withdraws so we don't charge fees on them\n        uint256 balanceForVaultFees = currentBalance -\n            params.lastQueuedWithdrawAmount;\n\n        {\n            (performanceFeeInAsset, , totalVaultFee) = VaultLifecycle\n            .getVaultFees(\n                balanceForVaultFees,\n                vaultState.lastLockedAmount,\n                vaultState.totalPending,\n                params.performanceFee,\n                params.managementFee\n            );\n        }\n\n        // Take into account the fee\n        // so we can calculate the newPricePerShare\n        currentBalance -= totalVaultFee;\n\n        {\n            newPricePerShare = ShareMath.pricePerShare(\n                params.currentShareSupply - lastQueuedWithdrawShares,\n                currentBalance - params.lastQueuedWithdrawAmount,\n                pendingAmount,\n                params.decimals\n            );\n\n            queuedWithdrawAmount =\n                params.lastQueuedWithdrawAmount +\n                ShareMath.sharesToAsset(\n                    params.currentQueuedWithdrawShares,\n                    newPricePerShare,\n                    params.decimals\n                );\n\n            // After closing the short, if the options expire in-the-money\n            // vault pricePerShare would go down because vault's asset balance decreased.\n            // This ensures that the newly-minted shares do not take on the loss.\n            mintShares = ShareMath.assetToShares(\n                pendingAmount,\n                newPricePerShare,\n                params.decimals\n            );\n        }\n\n        return (\n            currentBalance - queuedWithdrawAmount, // new locked balance subtracts the queued withdrawals\n            queuedWithdrawAmount,\n            newPricePerShare,\n            mintShares,\n            performanceFeeInAsset,\n            totalVaultFee\n        );\n    }\n\n    /**\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\n     * @param gammaController is the address of the opyn controller contract\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\n     * @param oTokenAddress is the address of the otoken to mint\n     * @param depositAmount is the amount of collateral to deposit\n     * @return the otoken mint amount\n     */\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID = (\n            controller.getAccountVaultCounter(address(this))\n        ) + 1;\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals = uint256(\n            IERC20Detailed(collateralAsset).decimals()\n        );\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount =\n                (depositAmount * (10**Vault.OTOKEN_DECIMALS) * (10**18)) / // we use 10**18 to give extra precision\n                (oToken.strikePrice() * (10**(10 + collateralDecimals)));\n        } else {\n            mintAmount = depositAmount;\n\n            if (collateralDecimals > 8) {\n                uint256 scaleBy = 10**(collateralDecimals - 8); // oTokens have 8 decimals\n                if (mintAmount > scaleBy) {\n                    mintAmount = depositAmount / scaleBy; // scale down from 10**18 to 10**8\n                }\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApproveNonCompliant(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            3\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // option address\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `_closeShort` deletes vaults by\n     calling SettleVault action, this assumption should hold.\n     * @param gammaController is the address of the opyn controller contract\n     * @return amount of collateral redeemed from the vault\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault = controller.getVault(\n            address(this),\n            vaultID\n        );\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        // The short position has been previously closed, or all the otokens have been burned.\n        // So we return early.\n        if (address(collateralToken) == address(0)) {\n            return 0;\n        }\n\n        // This is equivalent to doing IERC20(vault.asset).balanceOf(address(this))\n        uint256 startCollateralBalance = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            1\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance - startCollateralBalance;\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     * @param gammaController is the address of the opyn controller contract\n     * @param oldOption is the address of the old option\n     * @param asset is the address of the vault's asset\n     * @return amount of asset received by exercising the option\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            1\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance - startAssetBalance;\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     * @param gammaController is the address of the opyn controller contract\n     * @param currentOption is the address of the current option\n     * @return amount of collateral redeemed by burning otokens\n     */\n    function burnOtokens(address gammaController, address currentOption)\n        external\n        returns (uint256)\n    {\n        uint256 numOTokensToBurn = IERC20(currentOption).balanceOf(\n            address(this)\n        );\n\n        require(numOTokensToBurn > 0, \"No oTokens to burn\");\n\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault = controller.getVault(\n            address(this),\n            vaultID\n        );\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Burning `amount` of oTokens from the ribbon vault,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            2\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer from\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            numOTokensToBurn, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            (vault.collateralAmounts[0] * numOTokensToBurn) /\n                vault.shortAmounts[0], // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance - startCollateralBalance;\n    }\n\n    /**\n     * @notice Calculates the performance and management fee for this week's round\n     * @param currentBalance is the balance of funds held on the vault after closing short\n     * @param lastLockedAmount is the amount of funds locked from the previous round\n     * @param pendingAmount is the pending deposit amount\n     * @param performanceFeePercent is the performance fee pct.\n     * @param managementFeePercent is the management fee pct.\n     * @return performanceFeeInAsset is the performance fee\n     * @return managementFeeInAsset is the management fee\n     * @return vaultFee is the total fees\n     */\n    function getVaultFees(\n        uint256 currentBalance,\n        uint256 lastLockedAmount,\n        uint256 pendingAmount,\n        uint256 performanceFeePercent,\n        uint256 managementFeePercent\n    )\n        internal\n        pure\n        returns (\n            uint256 performanceFeeInAsset,\n            uint256 managementFeeInAsset,\n            uint256 vaultFee\n        )\n    {\n        // At the first round, currentBalance=0, pendingAmount>0\n        // so we just do not charge anything on the first round\n        uint256 lockedBalanceSansPending = currentBalance > pendingAmount\n            ? currentBalance - pendingAmount\n            : 0;\n\n        uint256 _performanceFeeInAsset;\n        uint256 _managementFeeInAsset;\n        uint256 _vaultFee;\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > lastLockedAmount) {\n            _performanceFeeInAsset = performanceFeePercent > 0\n                ? ((lockedBalanceSansPending - lastLockedAmount) *\n                    (performanceFeePercent)) / (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n            _managementFeeInAsset = managementFeePercent > 0\n                ? (lockedBalanceSansPending * managementFeePercent) /\n                    (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n\n            _vaultFee = _performanceFeeInAsset + _managementFeeInAsset;\n        }\n\n        return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\n    }\n\n    /**\n     * @notice Either retrieves the option token if it already exists, or deploy it\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param underlying is the address of the underlying asset of the option\n     * @param collateralAsset is the address of the collateral asset of the option\n     * @param strikePrice is the strike price of the option\n     * @param expiry is the expiry timestamp of the option\n     * @param isPut is whether the option is a put\n     * @return the address of the option\n     */\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory = factory.getOtoken(\n            underlying,\n            closeParams.USDC,\n            collateralAsset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken = factory.createOtoken(\n            underlying,\n            closeParams.USDC,\n            collateralAsset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        verifyOtoken(\n            otoken,\n            vaultParams,\n            collateralAsset,\n            closeParams.USDC,\n            closeParams.delay\n        );\n\n        return otoken;\n    }\n\n    function getOTokenPremium(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) external view returns (uint256) {\n        return\n            _getOTokenPremium(\n                oTokenAddress,\n                optionsPremiumPricer,\n                premiumDiscount\n            );\n    }\n\n    function _getOTokenPremium(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) internal view returns (uint256) {\n        IOtoken newOToken = IOtoken(oTokenAddress);\n        IOptionsPremiumPricer premiumPricer = IOptionsPremiumPricer(\n            optionsPremiumPricer\n        );\n\n        // Apply black-scholes formula (from rvol library) to option given its features\n        // and get price for 100 contracts denominated in the underlying asset for call option\n        // and USDC for put option\n        uint256 optionPremium = premiumPricer.getPremium(\n            newOToken.strikePrice(),\n            newOToken.expiryTimestamp(),\n            newOToken.isPut()\n        );\n\n        // Apply a discount to incentivize arbitraguers\n        optionPremium =\n            (optionPremium * premiumDiscount) /\n            (100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER);\n\n        require(\n            optionPremium <= type(uint96).max,\n            \"optionPremium > type(uint96) max value!\"\n        );\n        require(optionPremium > 0, \"!optionPremium\");\n\n        return optionPremium;\n    }\n\n    /**\n     * @notice Starts the gnosis auction\n     * @param auctionDetails is the struct with all the custom parameters of the auction\n     * @return the auction id of the newly created auction\n     */\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Settles the gnosis auction\n     * @param gnosisEasyAuction is the contract address of Gnosis easy auction protocol\n     * @param auctionID is the auction ID of the gnosis easy auction\n     */\n    function settleAuction(address gnosisEasyAuction, uint256 auctionID)\n        internal\n    {\n        IGnosisAuction(gnosisEasyAuction).settleAuction(auctionID);\n    }\n\n    /**\n     * @notice Places a bid in an auction\n     * @param bidDetails is the struct with all the details of the\n      bid including the auction's id and how much to bid\n     */\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    /**\n     * @notice Claims the oTokens belonging to the vault\n     * @param auctionSellOrder is the sell order of the bid\n     * @param gnosisEasyAuction is the address of the gnosis auction contract\n     holding custody to the funds\n     * @param counterpartyThetaVault is the address of the counterparty theta\n     vault of this delta vault\n     */\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    /**\n     * @notice Allocates the vault's minted options to the OptionsPurchaseQueue contract\n     * @dev Skipped if the optionsPurchaseQueue doesn't exist\n     * @param optionsPurchaseQueue is the OptionsPurchaseQueue contract\n     * @param option is the minted option\n     * @param optionsAmount is the amount of options minted\n     * @param optionAllocation is the maximum % of options to allocate towards the purchase queue (will only allocate\n     *  up to the amount that is on the queue)\n     * @return allocatedOptions is the amount of options that ended up getting allocated to the OptionsPurchaseQueue\n     */\n    function allocateOptions(\n        address optionsPurchaseQueue,\n        address option,\n        uint256 optionsAmount,\n        uint256 optionAllocation\n    ) external returns (uint256 allocatedOptions) {\n        // Skip if optionsPurchaseQueue is address(0)\n        if (optionsPurchaseQueue != address(0)) {\n            allocatedOptions =\n                (optionsAmount * optionAllocation) /\n                (100 * Vault.OPTION_ALLOCATION_MULTIPLIER);\n            allocatedOptions = IOptionsPurchaseQueue(optionsPurchaseQueue)\n            .getOptionsAllocation(address(this), allocatedOptions);\n\n            if (allocatedOptions != 0) {\n                IERC20(option).approve(optionsPurchaseQueue, allocatedOptions);\n                IOptionsPurchaseQueue(optionsPurchaseQueue).allocateOptions(\n                    allocatedOptions\n                );\n            }\n        }\n\n        return allocatedOptions;\n    }\n\n    /**\n     * @notice Sell the allocated options to the purchase queue post auction settlement\n     * @dev Reverts if the auction hasn't settled yet\n     * @param optionsPurchaseQueue is the OptionsPurchaseQueue contract\n     * @param gnosisEasyAuction The address of the Gnosis Easy Auction contract\n     * @return totalPremiums Total premiums earnt by the vault\n     */\n    function sellOptionsToQueue(\n        address optionsPurchaseQueue,\n        address gnosisEasyAuction,\n        uint256 optionAuctionID\n    ) external returns (uint256) {\n        uint256 settlementPrice = getAuctionSettlementPrice(\n            gnosisEasyAuction,\n            optionAuctionID\n        );\n        require(settlementPrice != 0, \"!settlementPrice\");\n\n        return\n            IOptionsPurchaseQueue(optionsPurchaseQueue).sellToBuyers(\n                settlementPrice\n            );\n    }\n\n    /**\n     * @notice Gets the settlement price of a settled auction\n     * @param gnosisEasyAuction The address of the Gnosis Easy Auction contract\n     * @return settlementPrice Auction settlement price\n     */\n    function getAuctionSettlementPrice(\n        address gnosisEasyAuction,\n        uint256 optionAuctionID\n    ) public view returns (uint256) {\n        bytes32 clearingPriceOrder = IGnosisAuction(gnosisEasyAuction)\n        .auctionData(optionAuctionID)\n        .clearingPriceOrder;\n\n        if (clearingPriceOrder == bytes32(0)) {\n            // Current auction hasn't settled yet\n            return 0;\n        } else {\n            // We decode the clearingPriceOrder to find the auction settlement price\n            // settlementPrice = clearingPriceOrder.sellAmount / clearingPriceOrder.buyAmount\n            return\n                ((10**Vault.OTOKEN_DECIMALS) *\n                    (uint96(uint256(clearingPriceOrder)))) / // sellAmount\n                (\n                    uint96(uint256(clearingPriceOrder) >> 96) // buyAmount\n                );\n        }\n    }\n\n    /**\n     * @notice Verify the constructor params satisfy requirements\n     * @param owner is the owner of the vault with critical permissions\n     * @param feeRecipient is the address to recieve vault performance and management fees\n     * @param performanceFee is the perfomance fee pct.\n     * @param tokenName is the name of the token\n     * @param tokenSymbol is the symbol of the token\n     * @param _vaultParams is the struct with vault general data\n     */\n    function verifyInitializerParams(\n        address owner,\n        address keeper,\n        address feeRecipient,\n        uint256 performanceFee,\n        uint256 managementFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(keeper != address(0), \"!keeper\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(\n            performanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"performanceFee >= 100%\"\n        );\n        require(\n            managementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"managementFee >= 100%\"\n        );\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(\n            _vaultParams.cap > _vaultParams.minimumSupply,\n            \"cap has to be higher than minimumSupply\"\n        );\n    }\n\n    /**\n     * @notice Gets the next option expiry timestamp\n     * @param currentOption is the otoken address that the vault is currently writing\n     */\n    function getNextExpiry(address currentOption)\n        internal\n        view\n        returns (uint256)\n    {\n        // uninitialized state\n        if (currentOption == address(0)) {\n            return getNextFriday(block.timestamp);\n        }\n        uint256 currentExpiry = IOtoken(currentOption).expiryTimestamp();\n\n        // After options expiry if no options are written for >1 week\n        // We need to give the ability continue writing options\n        if (block.timestamp > currentExpiry + 7 days) {\n            return getNextFriday(block.timestamp);\n        }\n        return getNextFriday(currentExpiry);\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param timestamp is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed timestamp is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (timestamp >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/libs/ShareMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Vault.sol\";\n\nlibrary ShareMath {\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    function assetToShares(\n        uint256 assetAmount,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return (assetAmount * 10**decimals) / assetPerShare;\n    }\n\n    function sharesToAsset(\n        uint256 shares,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return (shares * assetPerShare) / 10**decimals;\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param assetPerShare is the price in asset per share\n     * @param decimals is the number of decimals the asset/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256 unredeemedShares) {\n        if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\n            uint256 sharesFromRound = assetToShares(\n                depositReceipt.amount,\n                assetPerShare,\n                decimals\n            );\n\n            return uint256(depositReceipt.unredeemedShares) + sharesFromRound;\n        }\n        return depositReceipt.unredeemedShares;\n    }\n\n    function pricePerShare(\n        uint256 totalSupply,\n        uint256 totalBalance,\n        uint256 pendingAmount,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        uint256 singleShare = 10**decimals;\n        return\n            totalSupply > 0\n                ? (singleShare * (totalBalance - pendingAmount)) / totalSupply\n                : singleShare;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \"Overflow uint104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \"Overflow uint128\");\n    }\n}\n"
    },
    "contracts/libs/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary Vault {\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\n    uint256 internal constant FEE_MULTIPLIER = 10**6;\n\n    // Premium discount has 1-decimal place. For example: 80 * 10**1 = 80%. Which represents a 20% discount.\n    uint256 internal constant PREMIUM_DISCOUNT_MULTIPLIER = 10;\n\n    // Otokens have 8 decimal places.\n    uint256 internal constant OTOKEN_DECIMALS = 8;\n\n    // Percentage of funds allocated to options is 2 decimal places. 10 * 10**2 = 10%\n    uint256 internal constant OPTION_ALLOCATION_MULTIPLIER = 10**2;\n\n    // Placeholder uint value to prevent cold writes\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    struct VaultParams {\n        // Option type the vault is selling\n        bool isPut;\n        // Token decimals for vault shares\n        uint8 decimals;\n        // Asset used in Theta / Delta Vault\n        address asset;\n        // Underlying asset of the options sold by vault\n        address underlying;\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\n        uint56 minimumSupply;\n        // Vault cap\n        uint104 cap;\n    }\n\n    struct OptionState {\n        // Option that the vault is shorting / longing in the next cycle\n        address nextOption;\n        // Option that the vault is currently shorting / longing\n        address currentOption;\n        // The timestamp when the `nextOption` can be used by the vault\n        uint32 nextOptionReadyAt;\n    }\n\n    struct VaultState {\n        // 32 byte slot 1\n        //  Current round number. `round` represents the number of `period`s elapsed.\n        uint16 round;\n        // Amount that is currently locked for selling options\n        uint104 lockedAmount;\n        // Amount that was locked for selling options in the previous round\n        // used for calculating performance fee deduction\n        uint104 lastLockedAmount;\n        // 32 byte slot 2\n        // Stores the total tally of how much of `asset` there is\n        // to be used to mint rTHETA tokens\n        uint128 totalPending;\n        // Total amount of queued withdrawal shares from previous rounds (doesn't include the current round)\n        uint128 queuedWithdrawShares;\n    }\n\n    struct DepositReceipt {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\n        uint104 amount;\n        // Unredeemed shares balance\n        uint128 unredeemedShares;\n    }\n\n    struct Withdrawal {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Number of shares withdrawn\n        uint128 shares;\n    }\n\n    struct AuctionSellOrder {\n        // Amount of `asset` token offered in auction\n        uint96 sellAmount;\n        // Amount of oToken requested in auction\n        uint96 buyAmount;\n        // User Id of delta vault in latest gnosis auction\n        uint64 userId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/interfaces/IGnosisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary AuctionType {\n    struct AuctionData {\n        IERC20 auctioningToken;\n        IERC20 biddingToken;\n        uint256 orderCancellationEndDate;\n        uint256 auctionEndDate;\n        bytes32 initialAuctionOrder;\n        uint256 minimumBiddingAmountPerOrder;\n        uint256 interimSumBidAmount;\n        bytes32 interimOrder;\n        bytes32 clearingPriceOrder;\n        uint96 volumeClearingPriceOrder;\n        bool minFundingThresholdNotReached;\n        bool isAtomicClosureAllowed;\n        uint256 feeNumerator;\n        uint256 minFundingThreshold;\n    }\n}\n\ninterface IGnosisAuction {\n    function initiateAuction(\n        address _auctioningToken,\n        address _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes memory accessManagerContractData\n    ) external returns (uint256);\n\n    function auctionCounter() external view returns (uint256);\n\n    function auctionData(uint256 auctionId)\n        external\n        view\n        returns (AuctionType.AuctionData memory);\n\n    function auctionAccessManager(uint256 auctionId)\n        external\n        view\n        returns (address);\n\n    function auctionAccessData(uint256 auctionId)\n        external\n        view\n        returns (bytes memory);\n\n    function FEE_DENOMINATOR() external view returns (uint256);\n\n    function feeNumerator() external view returns (uint256);\n\n    function settleAuction(uint256 auctionId) external returns (bytes32);\n\n    function placeSellOrders(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external returns (uint64);\n\n    function claimFromParticipantOrder(\n        uint256 auctionId,\n        bytes32[] memory orders\n    ) external returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IOptionsPurchaseQueue.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IOptionsPurchaseQueue {\n    /**\n     * @dev Contains purchase request info\n     * @param optionsAmount Amount of options to purchase\n     * @param premiums Total premiums the buyer is spending to purchase the options (optionsAmount * ceilingPrice)\n     *  We need to track the premiums here since the ceilingPrice could change between the time the purchase was\n     *  requested and when the options are sold\n     * @param buyer The buyer requesting this purchase\n     */\n    struct Purchase {\n        uint128 optionsAmount; // Slot 0\n        uint128 premiums;\n        address buyer; // Slot 1\n    }\n\n    function purchases(address, uint256)\n        external\n        view\n        returns (\n            uint128,\n            uint128,\n            address\n        );\n\n    function totalOptionsAmount(address) external view returns (uint256);\n\n    function vaultAllocatedOptions(address) external view returns (uint256);\n\n    function whitelistedBuyer(address) external view returns (bool);\n\n    function minPurchaseAmount(address) external view returns (uint256);\n\n    function ceilingPrice(address) external view returns (uint256);\n\n    function getPurchases(address vault)\n        external\n        view\n        returns (Purchase[] memory);\n\n    function getPremiums(address vault, uint256 optionsAmount)\n        external\n        view\n        returns (uint256);\n\n    function getOptionsAllocation(address vault, uint256 allocatedOptions)\n        external\n        view\n        returns (uint256);\n\n    function requestPurchase(address vault, uint256 optionsAmount)\n        external\n        returns (uint256);\n\n    function allocateOptions(uint256 allocatedOptions)\n        external\n        returns (uint256);\n\n    function sellToBuyers(uint256 settlementPrice) external returns (uint256);\n\n    function cancelAllPurchases(address vault) external;\n\n    function addWhitelist(address buyer) external;\n\n    function removeWhitelist(address buyer) external;\n\n    function setCeilingPrice(address vault, uint256 price) external;\n\n    function setMinPurchaseAmount(address vault, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IRibbon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/Vault.sol\";\n\ninterface IRibbonVault {\n    function deposit(uint256 amount) external;\n\n    function depositETH() external payable;\n\n    function cap() external view returns (uint256);\n\n    function depositFor(uint256 amount, address creditor) external;\n\n    function vaultParams() external view returns (Vault.VaultParams memory);\n}\n\ninterface IStrikeSelection {\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256, uint256);\n\n    function delta() external view returns (uint256);\n}\n\ninterface IOptionsPremiumPricer {\n    function getPremium(\n        uint256 strikePrice,\n        uint256 timeToExpiry,\n        bool isPut\n    ) external view returns (uint256);\n\n    function getPremiumInStables(\n        uint256 strikePrice,\n        uint256 timeToExpiry,\n        bool isPut\n    ) external view returns (uint256);\n\n    function getOptionDelta(\n        uint256 spotPrice,\n        uint256 strikePrice,\n        uint256 volatility,\n        uint256 expiryTimestamp\n    ) external view returns (uint256 delta);\n\n    function getUnderlyingPrice() external view returns (uint256);\n\n    function priceOracle() external view returns (address);\n\n    function volatilityOracle() external view returns (address);\n\n    function optionId() external view returns (bytes32);\n}\n"
    },
    "contracts/libs/SupportsNonCompliantERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * This library supports ERC20s that have quirks in their behavior.\n * One such ERC20 is USDT, which requires allowance to be 0 before calling approve.\n * We plan to update this library with ERC20s that display such idiosyncratic behavior.\n */\nlibrary SupportsNonCompliantERC20 {\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function safeApproveNonCompliant(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (address(token) == USDT) {\n            SafeERC20.safeApprove(token, spender, 0);\n        }\n        SafeERC20.safeApprove(token, spender, amount);\n    }\n}\n"
    },
    "contracts/libs/GnosisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IRibbonThetaVault.sol\";\nimport \"../interfaces/IGnosisAuction.sol\";\nimport \"../interfaces/GammaInterface.sol\";\nimport \"../interfaces/IRibbon.sol\";\nimport \"../libs/DSMath.sol\";\nimport \"./Vault.sol\";\n\nlibrary GnosisAuction {\n    using SafeERC20 for IERC20;\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address indexed auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address indexed bidder\n    );\n\n    struct AuctionDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 oTokenPremium;\n        uint256 duration;\n    }\n\n    struct BidDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 auctionId;\n        uint256 lockedBalance;\n        uint256 optionAllocation;\n        uint256 optionPremium;\n        address bidder;\n    }\n\n    function startAuction(AuctionDetails calldata auctionDetails)\n        internal\n        returns (uint256 auctionID)\n    {\n        uint256 oTokenSellAmount = getOTokenSellAmount(\n            auctionDetails.oTokenAddress\n        );\n        require(oTokenSellAmount > 0, \"No otokens to sell\");\n\n        IERC20(auctionDetails.oTokenAddress).safeApprove(\n            auctionDetails.gnosisEasyAuction,\n            IERC20(auctionDetails.oTokenAddress).balanceOf(address(this))\n        );\n\n        // minBidAmount is total oTokens to sell * premium per oToken\n        // shift decimals to correspond to decimals of USDC for puts\n        // and underlying for calls\n        uint256 minBidAmount = DSMath.wmul(\n            oTokenSellAmount * 10**10,\n            auctionDetails.oTokenPremium\n        );\n\n        minBidAmount = auctionDetails.assetDecimals > 18\n            ? minBidAmount * 10**(auctionDetails.assetDecimals - 18)\n            : minBidAmount / (10**(uint256(18) - auctionDetails.assetDecimals));\n\n        require(\n            minBidAmount <= type(uint96).max,\n            \"optionPremium * oTokenSellAmount > type(uint96) max value!\"\n        );\n\n        uint256 auctionEnd = block.timestamp + auctionDetails.duration;\n\n        auctionID = IGnosisAuction(auctionDetails.gnosisEasyAuction)\n        .initiateAuction(\n            // address of oToken we minted and are selling\n            auctionDetails.oTokenAddress,\n            // address of asset we want in exchange for oTokens. Should match vault `asset`\n            auctionDetails.asset,\n            // orders can be cancelled at any time during the auction\n            auctionEnd,\n            // order will last for `duration`\n            auctionEnd,\n            // we are selling all of the otokens minus a fee taken by gnosis\n            uint96(oTokenSellAmount),\n            // the minimum we are willing to sell all the oTokens for. A discount is applied on black-scholes price\n            uint96(minBidAmount),\n            // the minimum bidding amount must be 1 * 10 ** -assetDecimals\n            1,\n            // the min funding threshold\n            0,\n            // no atomic closure\n            false,\n            // access manager contract\n            address(0),\n            // bytes for storing info like a whitelist for who can bid\n            bytes(\"\")\n        );\n\n        emit InitiateGnosisAuction(\n            auctionDetails.oTokenAddress,\n            auctionDetails.asset,\n            auctionID,\n            msg.sender\n        );\n    }\n\n    function placeBid(BidDetails calldata bidDetails)\n        internal\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        // calculate how much to allocate\n        sellAmount =\n            (bidDetails.lockedBalance * (bidDetails.optionAllocation)) /\n            (100 * Vault.OPTION_ALLOCATION_MULTIPLIER);\n\n        // divide the `asset` sellAmount by the target premium per oToken to\n        // get the number of oTokens to buy (8 decimals)\n        buyAmount =\n            (sellAmount *\n                (10**(bidDetails.assetDecimals + Vault.OTOKEN_DECIMALS))) /\n            (bidDetails.optionPremium) /\n            (10**bidDetails.assetDecimals);\n\n        require(\n            sellAmount <= type(uint96).max,\n            \"sellAmount > type(uint96) max value!\"\n        );\n        require(\n            buyAmount <= type(uint96).max,\n            \"buyAmount > type(uint96) max value!\"\n        );\n\n        // approve that amount\n        IERC20(bidDetails.asset).safeApprove(\n            bidDetails.gnosisEasyAuction,\n            sellAmount\n        );\n\n        uint96[] memory _minBuyAmounts = new uint96[](1);\n        uint96[] memory _sellAmounts = new uint96[](1);\n        bytes32[] memory _prevSellOrders = new bytes32[](1);\n        _minBuyAmounts[0] = uint96(buyAmount);\n        _sellAmounts[0] = uint96(sellAmount);\n        _prevSellOrders[\n            0\n        ] = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n        // place sell order with that amount\n        userId = IGnosisAuction(bidDetails.gnosisEasyAuction).placeSellOrders(\n            bidDetails.auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            \"0x\"\n        );\n\n        emit PlaceAuctionBid(\n            bidDetails.auctionId,\n            bidDetails.oTokenAddress,\n            sellAmount,\n            buyAmount,\n            bidDetails.bidder\n        );\n\n        return (sellAmount, buyAmount, userId);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) internal {\n        bytes32 order = encodeOrder(\n            auctionSellOrder.userId,\n            auctionSellOrder.buyAmount,\n            auctionSellOrder.sellAmount\n        );\n        bytes32[] memory orders = new bytes32[](1);\n        orders[0] = order;\n        IGnosisAuction(gnosisEasyAuction).claimFromParticipantOrder(\n            IRibbonThetaVault(counterpartyThetaVault).optionAuctionID(),\n            orders\n        );\n    }\n\n    function getOTokenSellAmount(address oTokenAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        // We take our current oToken balance. That will be our sell amount\n        // but otokens will be transferred to gnosis.\n        uint256 oTokenSellAmount = IERC20(oTokenAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            oTokenSellAmount <= type(uint96).max,\n            \"oTokenSellAmount > type(uint96) max value!\"\n        );\n\n        return oTokenSellAmount;\n    }\n\n    function getOTokenPremiumInStables(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) internal view returns (uint256) {\n        IOtoken newOToken = IOtoken(oTokenAddress);\n        IOptionsPremiumPricer premiumPricer = IOptionsPremiumPricer(\n            optionsPremiumPricer\n        );\n\n        // Apply black-scholes formula (from rvol library) to option given its features\n        // and get price for 100 contracts denominated USDC for both call and put options\n        uint256 optionPremium = premiumPricer.getPremiumInStables(\n            newOToken.strikePrice(),\n            newOToken.expiryTimestamp(),\n            newOToken.isPut()\n        );\n\n        // Apply a discount to incentivize arbitraguers\n        optionPremium =\n            (optionPremium * premiumDiscount) /\n            (100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER);\n\n        require(\n            optionPremium <= type(uint96).max,\n            \"optionPremium > type(uint96) max value!\"\n        );\n\n        return optionPremium;\n    }\n\n    function encodeOrder(\n        uint64 userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                (uint256(userId) << 192) +\n                    (uint256(buyAmount) << 96) +\n                    uint256(sellAmount)\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IRibbonThetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/Vault.sol\";\n\ninterface IRibbonThetaVault {\n    function currentOption() external view returns (address);\n\n    function nextOption() external view returns (address);\n\n    function vaultParams() external view returns (Vault.VaultParams memory);\n\n    function vaultState() external view returns (Vault.VaultState memory);\n\n    function optionState() external view returns (Vault.OptionState memory);\n\n    function optionAuctionID() external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function roundPricePerShare(uint256) external view returns (uint256);\n\n    function depositFor(uint256 amount, address creditor) external;\n\n    function initiateWithdraw(uint256 numShares) external;\n\n    function completeWithdraw() external;\n\n    function maxRedeem() external;\n\n    function depositYieldTokenFor(uint256 amount, address creditor) external;\n\n    function symbol() external view returns (string calldata);\n}\n"
    },
    "contracts/libs/DSMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/RibbonThetaVaultWithSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./interfaces/ILiquidityGauge.sol\";\nimport \"./interfaces/IVaultPauser.sol\";\nimport \"./interfaces/IRibbonThetaVaultWithSwap.sol\";\nimport \"./interfaces/ISwap.sol\";\nimport \"./libs/VaultLifecycleWithSwap.sol\";\nimport \"./libs/ShareMath.sol\";\nimport \"./libs/Vault.sol\";\nimport \"./RibbonThetaVaultStorage.sol\";\nimport \"./RibbonVault.sol\";\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonThetaVaultStorage.\n * RibbonThetaVault should not inherit from any other contract aside from RibbonVault, RibbonThetaVaultStorage\n */\ncontract RibbonThetaVaultWithSwap is\n    IRibbonThetaVaultWithSwap,\n    RibbonVault,\n    RibbonThetaVaultStorage\n{\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    // The minimum duration for an option auction.\n    uint256 private constant MIN_AUCTION_DURATION = 5 minutes;\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _swapContract is the contract address that facilitates bids settlement\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _swapContract\n    ) RibbonVault(_weth, _usdc, _gammaController, _marginPool, _swapContract) {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _initParams is the struct with vault initialization parameters\n     * @param _vaultParams is the struct with vault general data\n     */\n    function initialize(\n        InitParams calldata _initParams,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _initParams._owner,\n            _initParams._keeper,\n            _initParams._feeRecipient,\n            _initParams._managementFee,\n            _initParams._performanceFee,\n            _initParams._tokenName,\n            _initParams._tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _initParams._optionsPremiumPricer != address(0),\n            \"!_optionsPremiumPricer\"\n        );\n        require(\n            _initParams._strikeSelection != address(0),\n            \"!_strikeSelection\"\n        );\n\n        optionsPremiumPricer = _initParams._optionsPremiumPricer;\n        strikeSelection = _initParams._strikeSelection;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new strike selection contract\n     * @param newStrikeSelection is the address of the new strike selection contract\n     */\n    function setStrikeSelection(address newStrikeSelection) external onlyOwner {\n        require(newStrikeSelection != address(0), \"!newStrikeSelection\");\n        strikeSelection = newStrikeSelection;\n    }\n\n    /**\n     * @notice Sets the new options premium pricer contract\n     * @param newOptionsPremiumPricer is the address of the new strike selection contract\n     */\n    function setOptionsPremiumPricer(address newOptionsPremiumPricer)\n        external\n        onlyOwner\n    {\n        require(\n            newOptionsPremiumPricer != address(0),\n            \"!newOptionsPremiumPricer\"\n        );\n        optionsPremiumPricer = newOptionsPremiumPricer;\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * Should be called after closeRound if we are setting current week's strike\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice) external onlyOwner {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverrideRound = vaultState.round;\n    }\n\n    /**\n     * @notice Sets the new liquidityGauge contract for this vault\n     * @param newLiquidityGauge is the address of the new liquidityGauge contract\n     */\n    function setLiquidityGauge(address newLiquidityGauge) external onlyOwner {\n        liquidityGauge = newLiquidityGauge;\n    }\n\n    /**\n     * @notice Sets oToken Premium\n     * @param minPrice is the new oToken Premium in the units of 10**18\n     */\n    function setMinPrice(uint256 minPrice) external onlyKeeper {\n        require(minPrice > 0, \"!minPrice\");\n        currentOtokenPremium = minPrice;\n    }\n\n    /**\n     * @notice Sets the new Vault Pauser contract for this vault\n     * @param newVaultPauser is the address of the new vaultPauser contract\n     */\n    function setVaultPauser(address newVaultPauser) external onlyOwner {\n        vaultPauser = newVaultPauser;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt = depositReceipts[\n            msg.sender\n        ];\n\n        uint256 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = (receiptAmount - amount).toUint104();\n        vaultState.totalPending = (uint256(vaultState.totalPending) - amount)\n        .toUint128();\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        _initiateWithdraw(numShares);\n        currentQueuedWithdrawShares += numShares;\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw();\n        lastQueuedWithdrawAmount = (uint256(lastQueuedWithdrawAmount) -\n            withdrawAmount)\n        .toUint128();\n    }\n\n    /**\n     * @notice Stakes a users vault shares\n     * @param numShares is the number of shares to stake\n     */\n    function stake(uint256 numShares) external nonReentrant {\n        address _liquidityGauge = liquidityGauge;\n        require(_liquidityGauge != address(0)); // Removed revert msgs due to contract size limit\n        require(numShares > 0);\n        uint256 heldByAccount = balanceOf(msg.sender);\n        if (heldByAccount < numShares) {\n            _redeem(numShares - heldByAccount, false);\n        }\n        _transfer(msg.sender, address(this), numShares);\n        _approve(address(this), _liquidityGauge, numShares);\n        ILiquidityGauge(_liquidityGauge).deposit(numShares, msg.sender, false);\n    }\n\n    /**\n     * @notice Closes the existing short and calculate the shares to mint, new price per share &\n      amount of funds to re-allocate as collateral for the new round\n     * Since we are incrementing the round here, the options are sold in the beginning of a round\n     * instead of at the end of the round. For example, at round 1, we don't sell any options. We\n     * start selling options at the beginning of round 2.\n     */\n    function closeRound() external nonReentrant {\n        address oldOption = optionState.currentOption;\n        require(\n            oldOption != address(0) || vaultState.round == 1,\n            \"Round closed\"\n        );\n        _closeShort(oldOption);\n\n        uint256 currQueuedWithdrawShares = currentQueuedWithdrawShares;\n        (\n            ,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        ) = _rollToNextOption(\n            uint256(lastQueuedWithdrawAmount),\n            currQueuedWithdrawShares\n        );\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        uint256 newQueuedWithdrawShares = uint256(\n            vaultState.queuedWithdrawShares\n        ) + currQueuedWithdrawShares;\n        vaultState.queuedWithdrawShares = newQueuedWithdrawShares.toUint128();\n\n        currentQueuedWithdrawShares = 0;\n\n        vaultState.lockedAmount = lockedBalance.toUint104();\n\n        uint256 nextOptionReady = block.timestamp + DELAY;\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = nextOptionReady.toUint32();\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        uint256 lockedAmount = vaultState.lockedAmount;\n        if (oldOption != address(0)) {\n            vaultState.lastLockedAmount = lockedAmount.toUint104();\n        }\n        vaultState.lockedAmount = 0;\n\n        optionState.currentOption = address(0);\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount = VaultLifecycleWithSwap.settleShort(\n                GAMMA_CONTROLLER\n            );\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting\n     */\n    function commitNextOption() external onlyKeeper nonReentrant {\n        address currentOption = optionState.currentOption;\n        require(\n            currentOption == address(0) && vaultState.round != 1,\n            \"Round not closed\"\n        );\n\n\n            VaultLifecycleWithSwap.CommitParams memory commitParams\n         = VaultLifecycleWithSwap.CommitParams({\n            OTOKEN_FACTORY: OTOKEN_FACTORY,\n            USDC: USDC,\n            collateralAsset: vaultParams.asset,\n            currentOption: currentOption,\n            delay: DELAY,\n            lastStrikeOverrideRound: lastStrikeOverrideRound,\n            overriddenStrikePrice: overriddenStrikePrice,\n            strikeSelection: strikeSelection,\n            optionsPremiumPricer: optionsPremiumPricer\n        });\n\n        (\n            address otokenAddress,\n            uint256 strikePrice,\n            uint256 delta\n        ) = VaultLifecycleWithSwap.commitNextOption(\n            commitParams,\n            vaultParams,\n            vaultState\n        );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        optionState.nextOption = otokenAddress;\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position and create a new offer.\n     */\n    function rollToNextOption() external onlyKeeper nonReentrant {\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n        uint256 lockedBalance = vaultState.lockedAmount;\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycleWithSwap.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        _createOffer();\n    }\n\n    function _createOffer() private {\n        address currentOtoken = optionState.currentOption;\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        optionAuctionID = VaultLifecycleWithSwap.createOffer(\n            currentOtoken,\n            currOtokenPremium,\n            GNOSIS_EASY_AUCTION,\n            vaultParams\n        );\n    }\n\n    /**\n     * @notice Settle current offer\n     */\n    function settleOffer(ISwap.Bid[] calldata bids)\n        external\n        onlyKeeper\n        nonReentrant\n    {\n        ISwap(GNOSIS_EASY_AUCTION).settleOffer(optionAuctionID, bids);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over\n     */\n    function burnRemainingOTokens() external onlyKeeper nonReentrant {\n        VaultLifecycleWithSwap.burnOtokens(\n            GAMMA_CONTROLLER,\n            optionState.currentOption\n        );\n    }\n\n    /**\n     * @notice pause a user's vault position\n     */\n    function pausePosition() external {\n        address _vaultPauserAddress = vaultPauser;\n        require(_vaultPauserAddress != address(0)); // Removed revert msgs due to contract size limit\n        _redeem(0, true);\n        uint256 heldByAccount = balanceOf(msg.sender);\n        _approve(msg.sender, _vaultPauserAddress, heldByAccount);\n        IVaultPauser(_vaultPauserAddress).pausePosition(\n            msg.sender,\n            heldByAccount\n        );\n    }\n}\n"
    },
    "contracts/interfaces/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ILiquidityGauge {\n    function balanceOf(address) external view returns (uint256);\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/IVaultPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultPauser {\n    /// @notice pause vault position of an account with max amount\n    /// @param _account the address of user\n    /// @param _amount amount of shares\n    function pausePosition(address _account, uint256 _amount) external;\n\n    /// @notice resume vault position of an account with max amount\n    /// @param _vaultAddress the address of vault\n    function resumePosition(address _vaultAddress) external;\n}\n"
    },
    "contracts/interfaces/IRibbonThetaVaultWithSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/Vault.sol\";\nimport \"./ISwap.sol\";\n\ninterface IRibbonThetaVaultWithSwap {\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address indexed manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address indexed manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    event NewOffer(\n        uint256 swapId,\n        address seller,\n        address oToken,\n        address biddingToken,\n        uint256 minPrice,\n        uint256 minBidSize,\n        uint256 totalSize\n    );\n\n    /************************************************\n     *  STRUCTS\n     ***********************************************/\n\n    /**\n     * @notice Initialization parameters for the vault.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param _strikeSelection is the address of the contract with strike selection logic\n     */\n    struct InitParams {\n        address _owner;\n        address _keeper;\n        address _feeRecipient;\n        uint256 _managementFee;\n        uint256 _performanceFee;\n        string _tokenName;\n        string _tokenSymbol;\n        address _optionsPremiumPricer;\n        address _strikeSelection;\n    }\n\n    /**\n     * @notice Sets the new strike selection contract\n     * @param newStrikeSelection is the address of the new strike selection contract\n     */\n    function setStrikeSelection(address newStrikeSelection) external;\n\n    /**\n     * @notice Sets the new options premium pricer contract\n     * @param newOptionsPremiumPricer is the address of the new strike selection contract\n     */\n    function setOptionsPremiumPricer(address newOptionsPremiumPricer) external;\n\n    /**\n     * @notice Optionality to set strike price manually\n     * Should be called after closeRound if we are setting current week's strike\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice) external;\n\n    /**\n     * @notice Sets the new liquidityGauge contract for this vault\n     * @param newLiquidityGauge is the address of the new liquidityGauge contract\n     */\n    function setLiquidityGauge(address newLiquidityGauge) external;\n\n    /**\n     * @notice Sets oToken Premium\n     * @param minPrice is the new oToken Premium in the units of 10**18\n     */\n    function setMinPrice(uint256 minPrice) external;\n\n    /**\n     * @notice Sets the new Vault Pauser contract for this vault\n     * @param newVaultPauser is the address of the new vaultPauser contract\n     */\n    function setVaultPauser(address newVaultPauser) external;\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external;\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external;\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external;\n\n    /**\n     * @notice Stakes a users vault shares\n     * @param numShares is the number of shares to stake\n     */\n    function stake(uint256 numShares) external;\n\n    /**\n     * @notice Closes the existing short and calculate the shares to mint, new price per share &\n      amount of funds to re-allocate as collateral for the new round\n     * Since we are incrementing the round here, the options are sold in the beginning of a round\n     * instead of at the end of the round. For example, at round 1, we don't sell any options. We\n     * start selling options at the beginning of round 2.\n     */\n    function closeRound() external;\n\n    /**\n     * @notice Sets the next option the vault will be shorting\n     */\n    function commitNextOption() external;\n\n    /**\n     * @notice Rolls the vault's funds into a new short position and create a new offer.\n     */\n    function rollToNextOption() external;\n\n    /**\n     * @notice Settle current offer\n     */\n    function settleOffer(ISwap.Bid[] calldata bids) external;\n\n    /**\n     * @notice Burn the remaining oTokens left over\n     */\n    function burnRemainingOTokens() external;\n\n    /**\n     * @notice pause a user's vault position\n     */\n    function pausePosition() external;\n}\n"
    },
    "contracts/libs/VaultLifecycleWithSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IOptionsPurchaseQueue.sol\";\nimport \"../interfaces/GammaInterface.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/IRibbon.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"./SupportsNonCompliantERC20.sol\";\nimport \"./GnosisAuction.sol\";\nimport \"./ShareMath.sol\";\nimport \"./Vault.sol\";\n\nlibrary VaultLifecycleWithSwap {\n    using SupportsNonCompliantERC20 for IERC20;\n    using SafeERC20 for IERC20;\n\n    struct CommitParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address collateralAsset;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverrideRound;\n        uint256 overriddenStrikePrice;\n        address strikeSelection;\n        address optionsPremiumPricer;\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param commitParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return otokenAddress is the address of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitNextOption(\n        CommitParams calldata commitParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry = getNextExpiry(commitParams.currentOption);\n\n        IStrikeSelection selection = IStrikeSelection(\n            commitParams.strikeSelection\n        );\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n\n        (strikePrice, delta) = commitParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (commitParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = getOrDeployOtoken(\n            commitParams,\n            vaultParams,\n            underlying,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        return (otokenAddress, strikePrice, delta);\n    }\n\n    /**\n     * @notice Verify the otoken has the correct parameters to prevent vulnerability to opyn contract changes\n     * @param otokenAddress is the address of the otoken\n     * @param vaultParams is the struct with vault general data\n     * @param collateralAsset is the address of the collateral asset\n     * @param USDC is the address of usdc\n     * @param delay is the delay between commitAndClose and rollToNextOption\n     */\n    function verifyOtoken(\n        address otokenAddress,\n        Vault.VaultParams storage vaultParams,\n        address collateralAsset,\n        address USDC,\n        uint256 delay\n    ) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        require(otoken.isPut() == vaultParams.isPut, \"Type mismatch\");\n        require(\n            otoken.underlyingAsset() == vaultParams.underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(\n            otoken.collateralAsset() == collateralAsset,\n            \"Wrong collateralAsset\"\n        );\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp + delay;\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    /**\n     * @param decimals is the decimals of the asset\n     * @param totalBalance is the vault's total asset balance\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\n     * @param lastQueuedWithdrawAmount is the amount queued for withdrawals from last round\n     * @param performanceFee is the perf fee percent to charge on premiums\n     * @param managementFee is the management fee percent to charge on the AUM\n     */\n    struct CloseParams {\n        uint256 decimals;\n        uint256 totalBalance;\n        uint256 currentShareSupply;\n        uint256 lastQueuedWithdrawAmount;\n        uint256 performanceFee;\n        uint256 managementFee;\n        uint256 currentQueuedWithdrawShares;\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\n     * @param params is the rollover parameters passed to compute the next state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     * @return performanceFeeInAsset is the performance fee charged by vault\n     * @return totalVaultFee is the total amount of fee charged by vault\n     */\n    function closeRound(\n        Vault.VaultState storage vaultState,\n        CloseParams calldata params\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        uint256 currentBalance = params.totalBalance;\n        uint256 pendingAmount = vaultState.totalPending;\n        // Total amount of queued withdrawal shares from previous rounds (doesn't include the current round)\n        uint256 lastQueuedWithdrawShares = vaultState.queuedWithdrawShares;\n\n        // Deduct older queued withdraws so we don't charge fees on them\n        uint256 balanceForVaultFees = currentBalance -\n            params.lastQueuedWithdrawAmount;\n\n        {\n            (performanceFeeInAsset, , totalVaultFee) = getVaultFees(\n                balanceForVaultFees,\n                vaultState.lastLockedAmount,\n                vaultState.totalPending,\n                params.performanceFee,\n                params.managementFee\n            );\n        }\n\n        // Take into account the fee\n        // so we can calculate the newPricePerShare\n        currentBalance -= totalVaultFee;\n\n        {\n            newPricePerShare = ShareMath.pricePerShare(\n                params.currentShareSupply - lastQueuedWithdrawShares,\n                currentBalance - params.lastQueuedWithdrawAmount,\n                pendingAmount,\n                params.decimals\n            );\n\n            queuedWithdrawAmount =\n                params.lastQueuedWithdrawAmount +\n                ShareMath.sharesToAsset(\n                    params.currentQueuedWithdrawShares,\n                    newPricePerShare,\n                    params.decimals\n                );\n\n            // After closing the short, if the options expire in-the-money\n            // vault pricePerShare would go down because vault's asset balance decreased.\n            // This ensures that the newly-minted shares do not take on the loss.\n            mintShares = ShareMath.assetToShares(\n                pendingAmount,\n                newPricePerShare,\n                params.decimals\n            );\n        }\n\n        return (\n            currentBalance - queuedWithdrawAmount, // new locked balance subtracts the queued withdrawals\n            queuedWithdrawAmount,\n            newPricePerShare,\n            mintShares,\n            performanceFeeInAsset,\n            totalVaultFee\n        );\n    }\n\n    /**\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\n     * @param gammaController is the address of the opyn controller contract\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\n     * @param oTokenAddress is the address of the otoken to mint\n     * @param depositAmount is the amount of collateral to deposit\n     * @return the otoken mint amount\n     */\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID = (\n            controller.getAccountVaultCounter(address(this))\n        ) + 1;\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals = uint256(\n            IERC20Detailed(collateralAsset).decimals()\n        );\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount =\n                (depositAmount * (10**Vault.OTOKEN_DECIMALS) * (10**18)) / // we use 10**18 to give extra precision\n                (oToken.strikePrice() * (10**(10 + collateralDecimals)));\n        } else {\n            mintAmount = depositAmount;\n\n            if (collateralDecimals > 8) {\n                uint256 scaleBy = 10**(collateralDecimals - 8); // oTokens have 8 decimals\n                if (mintAmount > scaleBy) {\n                    mintAmount = depositAmount / scaleBy; // scale down from 10**18 to 10**8\n                }\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApproveNonCompliant(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            3\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // option address\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `_closeShort` deletes vaults by\n     calling SettleVault action, this assumption should hold.\n     * @param gammaController is the address of the opyn controller contract\n     * @return amount of collateral redeemed from the vault\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault = controller.getVault(\n            address(this),\n            vaultID\n        );\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        // The short position has been previously closed, or all the otokens have been burned.\n        // So we return early.\n        if (address(collateralToken) == address(0)) {\n            return 0;\n        }\n\n        // This is equivalent to doing IERC20(vault.asset).balanceOf(address(this))\n        uint256 startCollateralBalance = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            1\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance - startCollateralBalance;\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     * @param gammaController is the address of the opyn controller contract\n     * @param oldOption is the address of the old option\n     * @param asset is the address of the vault's asset\n     * @return amount of asset received by exercising the option\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            1\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance - startAssetBalance;\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     * @param gammaController is the address of the opyn controller contract\n     * @param currentOption is the address of the current option\n     * @return amount of collateral redeemed by burning otokens\n     */\n    function burnOtokens(address gammaController, address currentOption)\n        external\n        returns (uint256)\n    {\n        uint256 numOTokensToBurn = IERC20(currentOption).balanceOf(\n            address(this)\n        );\n\n        require(numOTokensToBurn > 0, \"No oTokens to burn\");\n\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault = controller.getVault(\n            address(this),\n            vaultID\n        );\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Burning `amount` of oTokens from the ribbon vault,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions = new IController.ActionArgs[](\n            2\n        );\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer from\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            numOTokensToBurn, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            (vault.collateralAmounts[0] * numOTokensToBurn) /\n                vault.shortAmounts[0], // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance - startCollateralBalance;\n    }\n\n    /**\n     * @notice Calculates the performance and management fee for this week's round\n     * @param currentBalance is the balance of funds held on the vault after closing short\n     * @param lastLockedAmount is the amount of funds locked from the previous round\n     * @param pendingAmount is the pending deposit amount\n     * @param performanceFeePercent is the performance fee pct.\n     * @param managementFeePercent is the management fee pct.\n     * @return performanceFeeInAsset is the performance fee\n     * @return managementFeeInAsset is the management fee\n     * @return vaultFee is the total fees\n     */\n    function getVaultFees(\n        uint256 currentBalance,\n        uint256 lastLockedAmount,\n        uint256 pendingAmount,\n        uint256 performanceFeePercent,\n        uint256 managementFeePercent\n    )\n        internal\n        pure\n        returns (\n            uint256 performanceFeeInAsset,\n            uint256 managementFeeInAsset,\n            uint256 vaultFee\n        )\n    {\n        // At the first round, currentBalance=0, pendingAmount>0\n        // so we just do not charge anything on the first round\n        uint256 lockedBalanceSansPending = currentBalance > pendingAmount\n            ? currentBalance - pendingAmount\n            : 0;\n\n        uint256 _performanceFeeInAsset;\n        uint256 _managementFeeInAsset;\n        uint256 _vaultFee;\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > lastLockedAmount) {\n            _performanceFeeInAsset = performanceFeePercent > 0\n                ? ((lockedBalanceSansPending - lastLockedAmount) *\n                    (performanceFeePercent)) / (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n            _managementFeeInAsset = managementFeePercent > 0\n                ? (lockedBalanceSansPending * managementFeePercent) /\n                    (100 * Vault.FEE_MULTIPLIER)\n                : 0;\n\n            _vaultFee = _performanceFeeInAsset + _managementFeeInAsset;\n        }\n\n        return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\n    }\n\n    /**\n     * @notice Either retrieves the option token if it already exists, or deploy it\n     * @param commitParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param underlying is the address of the underlying asset of the option\n     * @param strikePrice is the strike price of the option\n     * @param expiry is the expiry timestamp of the option\n     * @param isPut is whether the option is a put\n     * @return the address of the option\n     */\n    function getOrDeployOtoken(\n        CommitParams calldata commitParams,\n        Vault.VaultParams storage vaultParams,\n        address underlying,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(commitParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory = factory.getOtoken(\n            underlying,\n            commitParams.USDC,\n            commitParams.collateralAsset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken = factory.createOtoken(\n            underlying,\n            commitParams.USDC,\n            commitParams.collateralAsset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        verifyOtoken(\n            otoken,\n            vaultParams,\n            commitParams.collateralAsset,\n            commitParams.USDC,\n            commitParams.delay\n        );\n\n        return otoken;\n    }\n\n    /**\n     * @notice Creates an offer in the Swap Contract\n     * @param currentOtoken is the current otoken address\n     * @param currOtokenPremium is premium for each otoken\n     * @param swapContract the address of the swap contract\n     * @param vaultParams is the struct with vault general data\n     * @return optionAuctionID auction id of the newly created offer\n     */\n    function createOffer(\n        address currentOtoken,\n        uint256 currOtokenPremium,\n        address swapContract,\n        Vault.VaultParams storage vaultParams\n    ) external returns (uint256 optionAuctionID) {\n        require(\n            currOtokenPremium <= type(uint96).max,\n            \"currentOtokenPremium > type(uint96) max value!\"\n        );\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        uint256 oTokenBalance = IERC20(currentOtoken).balanceOf(address(this));\n        require(\n            oTokenBalance <= type(uint128).max,\n            \"oTokenBalance > type(uint128) max value!\"\n        );\n\n        // Use safeIncrease instead of safeApproval because safeApproval is only used for initial\n        // approval and cannot be called again. Using safeIncrease allow us to call _createOffer\n        // even when we are approving the same oTokens we have used before. This might happen if\n        // we accidentally burn the oTokens before settlement.\n        uint256 allowance = IERC20(currentOtoken).allowance(\n            address(this),\n            swapContract\n        );\n\n        if (allowance < oTokenBalance) {\n            IERC20(currentOtoken).safeIncreaseAllowance(\n                swapContract,\n                oTokenBalance - allowance\n            );\n        }\n\n        uint256 decimals = vaultParams.decimals;\n\n        // If total size is larger than 1, set minimum bid as 1\n        // Otherwise, set minimum bid to one tenth the total size\n        uint256 minBidSize = oTokenBalance > 10**decimals\n            ? 10**decimals\n            : oTokenBalance / 10;\n\n        require(\n            minBidSize <= type(uint96).max,\n            \"minBidSize > type(uint96) max value!\"\n        );\n\n        currOtokenPremium = decimals > 18\n            ? currOtokenPremium * (10**(decimals - 18))\n            : currOtokenPremium / (10**(uint256(18) - decimals));\n\n        optionAuctionID = ISwap(swapContract).createOffer(\n            currentOtoken,\n            vaultParams.asset,\n            uint96(currOtokenPremium),\n            uint96(minBidSize),\n            uint128(oTokenBalance)\n        );\n    }\n\n    /**\n     * @notice Allocates the vault's minted options to the OptionsPurchaseQueue contract\n     * @dev Skipped if the optionsPurchaseQueue doesn't exist\n     * @param optionsPurchaseQueue is the OptionsPurchaseQueue contract\n     * @param option is the minted option\n     * @param optionsAmount is the amount of options minted\n     * @param optionAllocation is the maximum % of options to allocate towards the purchase queue (will only allocate\n     *  up to the amount that is on the queue)\n     * @return allocatedOptions is the amount of options that ended up getting allocated to the OptionsPurchaseQueue\n     */\n    function allocateOptions(\n        address optionsPurchaseQueue,\n        address option,\n        uint256 optionsAmount,\n        uint256 optionAllocation\n    ) external returns (uint256 allocatedOptions) {\n        // Skip if optionsPurchaseQueue is address(0)\n        if (optionsPurchaseQueue != address(0)) {\n            allocatedOptions =\n                (optionsAmount * optionAllocation) /\n                (100 * Vault.OPTION_ALLOCATION_MULTIPLIER);\n            allocatedOptions = IOptionsPurchaseQueue(optionsPurchaseQueue)\n            .getOptionsAllocation(address(this), allocatedOptions);\n\n            if (allocatedOptions != 0) {\n                IERC20(option).approve(optionsPurchaseQueue, allocatedOptions);\n                IOptionsPurchaseQueue(optionsPurchaseQueue).allocateOptions(\n                    allocatedOptions\n                );\n            }\n        }\n\n        return allocatedOptions;\n    }\n\n    /**\n     * @notice Sell the allocated options to the purchase queue post auction settlement\n     * @dev Reverts if the auction hasn't settled yet\n     * @param optionsPurchaseQueue is the OptionsPurchaseQueue contract\n     * @param swapContract The address of the swap settlement contract\n     * @return totalPremiums Total premiums earnt by the vault\n     */\n    function sellOptionsToQueue(\n        address optionsPurchaseQueue,\n        address swapContract,\n        uint256 optionAuctionID\n    ) external returns (uint256) {\n        uint256 settlementPrice = getAuctionSettlementPrice(\n            swapContract,\n            optionAuctionID\n        );\n        require(settlementPrice != 0, \"!settlementPrice\");\n\n        return\n            IOptionsPurchaseQueue(optionsPurchaseQueue).sellToBuyers(\n                settlementPrice\n            );\n    }\n\n    /**\n     * @notice Gets the settlement price of a settled auction\n     * @param swapContract The address of the swap settlement contract\n     * @param optionAuctionID is the offer ID\n     * @return settlementPrice Auction settlement price\n     */\n    function getAuctionSettlementPrice(\n        address swapContract,\n        uint256 optionAuctionID\n    ) public view returns (uint256) {\n        return ISwap(swapContract).averagePriceForOffer(optionAuctionID);\n    }\n\n    /**\n     * @notice Verify the constructor params satisfy requirements\n     * @param owner is the owner of the vault with critical permissions\n     * @param feeRecipient is the address to recieve vault performance and management fees\n     * @param performanceFee is the perfomance fee pct.\n     * @param tokenName is the name of the token\n     * @param tokenSymbol is the symbol of the token\n     * @param _vaultParams is the struct with vault general data\n     */\n    function verifyInitializerParams(\n        address owner,\n        address keeper,\n        address feeRecipient,\n        uint256 performanceFee,\n        uint256 managementFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(keeper != address(0), \"!keeper\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(\n            performanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"performanceFee >= 100%\"\n        );\n        require(\n            managementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"managementFee >= 100%\"\n        );\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(\n            _vaultParams.cap > _vaultParams.minimumSupply,\n            \"cap has to be higher than minimumSupply\"\n        );\n    }\n\n    /**\n     * @notice Gets the next option expiry timestamp\n     * @param currentOption is the otoken address that the vault is currently writing\n     */\n    function getNextExpiry(address currentOption)\n        internal\n        view\n        returns (uint256)\n    {\n        // uninitialized state\n        if (currentOption == address(0)) {\n            return getNextFriday(block.timestamp);\n        }\n        uint256 currentExpiry = IOtoken(currentOption).expiryTimestamp();\n\n        // After options expiry if no options are written for >1 week\n        // We need to give the ability continue writing options\n        if (block.timestamp > currentExpiry + 7 days) {\n            return getNextFriday(block.timestamp);\n        }\n        return getNextFriday(currentExpiry);\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param timestamp is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed timestamp is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (timestamp >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n"
    },
    "contracts/RibbonThetaVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract RibbonThetaVaultStorageV1 {\n    // Logic contract used to price options\n    address public optionsPremiumPricer;\n    // Logic contract used to select strike prices\n    address public strikeSelection;\n    // Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint256 public premiumDiscount;\n    // Current oToken premium\n    uint256 public currentOtokenPremium;\n    // Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverrideRound;\n    // Price last overridden strike set to\n    uint256 public overriddenStrikePrice;\n    // Auction duration\n    uint256 public auctionDuration;\n    // Auction id of current option\n    uint256 public optionAuctionID;\n}\n\nabstract contract RibbonThetaVaultStorageV2 {\n    // Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n}\n\nabstract contract RibbonThetaVaultStorageV3 {\n    // DEPRECATED: Auction will be denominated in USDC if true\n    bool private _isUsdcAuction;\n    // DEPRECATED: Path for swaps\n    bytes private _swapPath;\n}\n\nabstract contract RibbonThetaVaultStorageV4 {\n    // LiquidityGauge contract for the vault\n    address public liquidityGauge;\n}\n\nabstract contract RibbonThetaVaultStorageV5 {\n    // OptionsPurchaseQueue contract for selling options\n    address public optionsPurchaseQueue;\n}\n\nabstract contract RibbonThetaVaultStorageV6 {\n    // Queued withdraw shares for the current round\n    uint256 public currentQueuedWithdrawShares;\n}\n\nabstract contract RibbonThetaVaultStorageV7 {\n    // Vault Pauser Contract for the vault\n    address public vaultPauser;\n}\n\nabstract contract RibbonThetaVaultStorageV8 {\n    // DEPRECATED: Executor role for Swap offers\n    address private _offerExecutor;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonThetaVaultStorage\n// e.g. RibbonThetaVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonThetaVaultStorage is RibbonThetaVaultStorageV1, RibbonThetaVaultStorageV2\nabstract contract RibbonThetaVaultStorage is\n    RibbonThetaVaultStorageV1,\n    RibbonThetaVaultStorageV2,\n    RibbonThetaVaultStorageV3,\n    RibbonThetaVaultStorageV4,\n    RibbonThetaVaultStorageV5,\n    RibbonThetaVaultStorageV6,\n    RibbonThetaVaultStorageV7,\n    RibbonThetaVaultStorageV8\n{\n\n}\n"
    },
    "contracts/RibbonVaultPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IVaultPauser.sol\";\nimport \"./libs/Vault.sol\";\nimport \"./interfaces/IRibbonThetaVault.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./libs/ShareMath.sol\";\n\ncontract RibbonVaultPauser is Ownable, IVaultPauser {\n    using SafeERC20 for IERC20;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores all the vault's paused positions\n    struct PauseReceipt {\n        uint16 round;\n        uint128 shares;\n    }\n\n    mapping(address => mapping(address => PauseReceipt)) public pausedPositions;\n    mapping(address => bool) private registeredVaults;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n    address public immutable STETH;\n    address public immutable STETH_VAULT;\n\n    address public keeper;\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Pause(\n        address indexed account,\n        address indexed vaultAddress,\n        uint256 share,\n        uint256 round\n    );\n\n    event Resume(\n        address indexed account,\n        address indexed vaultAddress,\n        uint256 withdrawAmount\n    );\n\n    event ProcessWithdrawal(address indexed vaultAddress, uint256 round);\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     */\n    constructor(\n        address _keeper,\n        address _weth,\n        address _steth,\n        address _steth_vault\n    ) {\n        require(_keeper != address(0), \"!_keeper\");\n        require(_weth != address(0), \"!_weth\");\n        require(_steth != address(0), \"!_steth\");\n        require(_steth_vault != address(0), \"!_steth_vault\");\n\n        keeper = _keeper;\n        WETH = _weth;\n        STETH = _steth;\n        STETH_VAULT = _steth_vault;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    function getPausePosition(address _vaultAddress, address _userAddress)\n        external\n        view\n        returns (PauseReceipt memory)\n    {\n        return pausedPositions[_vaultAddress][_userAddress];\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param _newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address _newKeeper) external onlyOwner {\n        require(_newKeeper != address(0), \"!newKeeper\");\n        keeper = _newKeeper;\n    }\n\n    /**\n     * @notice add vault into registered vaults\n     * @param _vaultAddress is the address of the new vault to be registered\n     */\n    function addVault(address _vaultAddress) external onlyOwner {\n        registeredVaults[_vaultAddress] = true;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice pause position from vault by redeem all the shares from vault to Pauser\n     * @param _account user's address\n     * @param _amount the amount of shares\n     */\n    function pausePosition(address _account, uint256 _amount)\n        external\n        override\n    {\n        address currentVaultAddress = msg.sender;\n        IRibbonThetaVault currentVault = IRibbonThetaVault(currentVaultAddress);\n\n        // check if vault is registered\n        require(\n            registeredVaults[currentVaultAddress],\n            \"Vault is not registered\"\n        );\n\n        PauseReceipt storage pausedPosition = pausedPositions[\n            currentVaultAddress\n        ][_account];\n\n        // check if position is paused\n        require(\n            pausedPosition.shares == 0 && pausedPosition.round == 0,\n            \"Position is paused\"\n        );\n\n        uint16 round = currentVault.vaultState().round;\n\n        require(_amount < type(uint128).max, \"_amount overflow\");\n\n        pausedPositions[currentVaultAddress][_account] = PauseReceipt({\n            round: round,\n            shares: uint128(_amount)\n        });\n\n        emit Pause(_account, currentVaultAddress, _amount, round);\n\n        // transfer from user to pauser\n        IERC20(currentVaultAddress).safeTransferFrom(\n            _account,\n            address(this),\n            _amount\n        );\n\n        currentVault.initiateWithdraw(_amount);\n    }\n\n    /**\n     * @notice resume user's position into vault by making a deposit\n     * @param _vaultAddress vault's address\n     */\n    function resumePosition(address _vaultAddress) external override {\n        IRibbonThetaVault currentVault = IRibbonThetaVault(_vaultAddress);\n\n        // check if vault is registered\n        require(registeredVaults[_vaultAddress], \"Vault is not registered\");\n\n        // get params and round\n        Vault.VaultParams memory currentParams = currentVault.vaultParams();\n        uint256 round = currentVault.vaultState().round;\n\n        PauseReceipt storage pauseReceipt = pausedPositions[_vaultAddress][\n            msg.sender\n        ];\n        uint256 pauseReceiptRound = pauseReceipt.round;\n\n        // check if roun is closed before resuming position\n        require(pauseReceiptRound < round, \"Round not closed yet\");\n        uint256 totalWithdrawAmount = ShareMath.sharesToAsset(\n            pauseReceipt.shares,\n            currentVault.roundPricePerShare(pauseReceiptRound),\n            currentParams.decimals\n        );\n\n        // delete position once transfer (revert to zero)\n        delete pausedPositions[_vaultAddress][msg.sender];\n\n        // stETH transfers suffer from an off-by-1 error\n        // since we received STETH , we shall deposit using STETH instead of ETH\n        if (_vaultAddress == STETH_VAULT) {\n            totalWithdrawAmount = totalWithdrawAmount - 3;\n\n            emit Resume(msg.sender, _vaultAddress, totalWithdrawAmount - 1);\n            IERC20(STETH).safeApprove(_vaultAddress, totalWithdrawAmount);\n            currentVault.depositYieldTokenFor(totalWithdrawAmount, msg.sender);\n        } else {\n            emit Resume(msg.sender, _vaultAddress, totalWithdrawAmount);\n\n            // if asset is ETH, we will convert it into WETH before depositing\n            if (currentParams.asset == WETH) {\n                IWETH(WETH).deposit{value: totalWithdrawAmount}();\n            }\n            IERC20(currentParams.asset).safeApprove(\n                _vaultAddress,\n                totalWithdrawAmount\n            );\n\n            currentVault.depositFor(totalWithdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice process withdrawals by completing in a batch\n     * @param _vaultAddress vault's address to be processed\n     */\n    function processWithdrawal(address _vaultAddress) external onlyKeeper {\n        IRibbonThetaVault currentVault = IRibbonThetaVault(_vaultAddress);\n        // we can only process withdrawal after closing the previous round\n        // hence round should be - 1\n        emit ProcessWithdrawal(\n            _vaultAddress,\n            currentVault.vaultState().round - 1\n        );\n        currentVault.completeWithdraw();\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/OptionsPremiumPricerInStables.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IERC20Detailed.sol\";\nimport \"./interfaces/IManualVolatilityOracle.sol\";\nimport \"./libs/DSMath.sol\";\nimport \"./libs/Math.sol\";\n\ncontract OptionsPremiumPricerInStables {\n    /**\n     * Immutables\n     */\n    bytes32 public immutable optionId;\n    IManualVolatilityOracle public immutable volatilityOracle;\n    IPriceOracle public immutable priceOracle;\n    IPriceOracle public immutable stablesOracle;\n    uint256 private immutable priceOracleDecimals;\n    uint256 private immutable stablesOracleDecimals;\n\n    // For reference - IKEEP3rVolatility: 0xCCdfCB72753CfD55C5afF5d98eA5f9C43be9659d\n\n    /**\n     * @notice Constructor for pricer, deploy one for every optionId\n     * @param _optionId is the bytes32 of the Option struct specifiying collateral, underlying, delta, and isPut\n     * @param _volatilityOracle is the oracle for historical volatility\n     * @param _priceOracle is the Chainlink price oracle for the underlying asset\n     * @param _stablesOracle is the Chainlink price oracle for the strike asset (e.g. USDC)\n     */\n    constructor(\n        bytes32 _optionId,\n        address _volatilityOracle,\n        address _priceOracle,\n        address _stablesOracle\n    ) {\n        require(_optionId.length > 0, \"!_optionId\");\n        require(_volatilityOracle != address(0), \"!_volatilityOracle\");\n        require(_priceOracle != address(0), \"!_priceOracle\");\n        require(_stablesOracle != address(0), \"!_stablesOracle\");\n\n        optionId = _optionId;\n        volatilityOracle = IManualVolatilityOracle(_volatilityOracle);\n        priceOracle = IPriceOracle(_priceOracle);\n        stablesOracle = IPriceOracle(_stablesOracle);\n        priceOracleDecimals = IPriceOracle(_priceOracle).decimals();\n        stablesOracleDecimals = IPriceOracle(_stablesOracle).decimals();\n    }\n\n    /**\n     * @notice Calculates the premium of the provided option using Black-Scholes\n     * References for Black-Scholes:\n       https://www.macroption.com/black-scholes-formula/\n       https://www.investopedia.com/terms/b/blackscholes.asp\n       https://www.erieri.com/blackscholes\n       https://goodcalculators.com/black-scholes-calculator/\n       https://www.calkoo.com/en/black-scholes-option-pricing-model\n     * @param st is the strike price of the option\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @param isPut is whether the option is a put option\n     * @return premium for 100 contracts with 18 decimals i.e.\n     * 500*10**18 = 500 USDC for 100 contracts for puts,\n     * 5*10**18 = 5 of underlying asset (ETH, WBTC, etc.) for 100 contracts for calls,\n     */\n    function getPremium(\n        uint256 st,\n        uint256 expiryTimestamp,\n        bool isPut\n    ) external view returns (uint256 premium) {\n        uint256 sp = priceOracle.latestAnswer();\n        (uint256 assetPrice, uint256 assetDecimals) = isPut\n            ? (stablesOracle.latestAnswer(), stablesOracleDecimals)\n            : (sp, priceOracleDecimals);\n\n        premium = _getPremium(\n            st,\n            sp,\n            expiryTimestamp,\n            assetPrice,\n            assetDecimals,\n            isPut\n        );\n    }\n\n    /**\n     * @notice Calculates the premium of the provided option using Black-Scholes in stables\n     * @param st is the strike price of the option\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @param isPut is whether the option is a put option\n     * @return premium for 100 contracts with 18 decimals\n     */\n    function getPremiumInStables(\n        uint256 st,\n        uint256 expiryTimestamp,\n        bool isPut\n    ) external view returns (uint256 premium) {\n        premium = _getPremium(\n            st,\n            priceOracle.latestAnswer(),\n            expiryTimestamp,\n            stablesOracle.latestAnswer(),\n            stablesOracleDecimals,\n            isPut\n        );\n    }\n\n    /**\n     * @notice Internal function to calculate the premium of the provided option using Black-Scholes\n     * @param st is the strike price of the option\n     * @param sp is the spot price of the underlying asset\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @param assetPrice is the denomination asset for the options\n     * @param assetDecimals is the decimals points of the denomination asset price\n     * @param isPut is whether the option is a put option\n     * @return premium for 100 contracts with 18 decimals\n     */\n    function _getPremium(\n        uint256 st,\n        uint256 sp,\n        uint256 expiryTimestamp,\n        uint256 assetPrice,\n        uint256 assetDecimals,\n        bool isPut\n    ) internal view returns (uint256 premium) {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        uint256 v;\n        uint256 t;\n        (sp, v, t) = blackScholesParams(sp, expiryTimestamp);\n\n        (uint256 call, uint256 put) = quoteAll(t, v, sp, st);\n\n        // Multiplier to convert oracle latestAnswer to 18 decimals\n        uint256 assetOracleMultiplier = 10**uint256(18) - assetDecimals;\n\n        // Make option premium denominated in the underlying\n        // asset for call vaults and USDC for put vaults\n        premium = isPut\n            ? DSMath.wdiv(put, assetPrice * assetOracleMultiplier)\n            : DSMath.wdiv(call, assetPrice * assetOracleMultiplier);\n\n        // Convert to 18 decimals\n        premium *= assetOracleMultiplier;\n    }\n\n    /**\n     * @notice Calculates the option's delta\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\n     * http://www.optiontradingpedia.com/options_delta.htm\n     * https://www.macroption.com/black-scholes-formula/\n     * @notice ONLY used when spot oracle is denominated in USDC\n     * @param st is the strike price of the option\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\n     * module recognizes\n     */\n    function getOptionDelta(uint256 st, uint256 expiryTimestamp)\n        external\n        view\n        returns (uint256 delta)\n    {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        uint256 spotPrice = priceOracle.latestAnswer();\n        (uint256 sp, uint256 v, ) = blackScholesParams(\n            spotPrice,\n            expiryTimestamp\n        );\n\n        delta = _getOptionDelta(sp, st, v, expiryTimestamp);\n    }\n\n    /**\n     * @notice Calculates the option's delta\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\n     * http://www.optiontradingpedia.com/options_delta.htm\n     * https://www.macroption.com/black-scholes-formula/\n     * @param sp is the spot price of the option\n     * @param st is the strike price of the option\n     * @param v is the annualized volatility of the underlying asset\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\n     * module recognizes\n     */\n    function getOptionDelta(\n        uint256 sp,\n        uint256 st,\n        uint256 v,\n        uint256 expiryTimestamp\n    ) external view returns (uint256 delta) {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        delta = _getOptionDelta(sp, st, v, expiryTimestamp);\n    }\n\n    /**\n     * @notice Internal function to calculate the option's delta\n     * @param st is the strike price of the option\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\n     * module recognizes\n     */\n    function _getOptionDelta(\n        uint256 sp,\n        uint256 st,\n        uint256 v,\n        uint256 expiryTimestamp\n    ) internal view returns (uint256 delta) {\n        // days until expiry\n        uint256 t = (expiryTimestamp - block.timestamp) / (1 days);\n\n        uint256 d1;\n        uint256 d2;\n\n        // Divide delta by 10 ** 10 to bring it to 4 decimals for strike selection\n        if (sp >= st) {\n            (d1, d2) = derivatives(t, v, sp, st);\n            delta = Math.ncdf((Math.FIXED_1 * d1) / 1e18) / (10**10);\n        } else {\n            // If underlying < strike price notice we switch st <-> sp passed into d\n            (d1, d2) = derivatives(t, v, st, sp);\n            delta =\n                uint256(10) *\n                (10**13) -\n                (Math.ncdf((Math.FIXED_1 * d2) / 1e18)) /\n                (10**10);\n        }\n    }\n\n    /**\n     * @notice Calculates black scholes for both put and call\n     * @param t is the days until expiry\n     * @param v is the annualized volatility\n     * @param sp is the underlying price\n     * @param st is the strike price\n     * @return call is the premium of the call option given parameters\n     * @return put is the premium of the put option given parameters\n     */\n    function quoteAll(\n        uint256 t,\n        uint256 v,\n        uint256 sp,\n        uint256 st\n    ) private pure returns (uint256 call, uint256 put) {\n        uint256 _c;\n        uint256 _p;\n\n        if (sp > st) {\n            _c = blackScholes(t, v, sp, st);\n            _p = DSMath.max(_c + st, sp) == sp ? 0 : _c + st - sp;\n        } else {\n            _p = blackScholes(t, v, st, sp);\n            _c = DSMath.max(_p + sp, st) == st ? 0 : _p + sp - st;\n        }\n\n        return (_c, _p);\n    }\n\n    /**\n     * @notice Calculates black scholes for the ITM option at mint given strike\n     * price and underlying given the parameters (if underling >= strike price this is\n     * premium of call, and put otherwise)\n     * @param t is the days until expiry\n     * @param v is the annualized volatility\n     * @param sp is the underlying price\n     * @param st is the strike price\n     * @return premium is the premium of option\n     */\n    function blackScholes(\n        uint256 t,\n        uint256 v,\n        uint256 sp,\n        uint256 st\n    ) private pure returns (uint256 premium) {\n        (uint256 d1, uint256 d2) = derivatives(t, v, sp, st);\n\n        uint256 cdfD1 = Math.ncdf((Math.FIXED_1 * d1) / 1e18);\n        uint256 cdfD2 = Math.cdf((int256(Math.FIXED_1) * int256(d2)) / 1e18);\n\n        premium = (sp * cdfD1) / 1e14 - (st * cdfD2) / 1e14;\n    }\n\n    /**\n     * @notice Calculates d1 and d2 used in black scholes calculation\n     * as parameters to black scholes calculations\n     * @param t is the days until expiry\n     * @param v is the annualized volatility\n     * @param sp is the underlying price\n     * @param st is the strike price\n     * @return d1 and d2\n     */\n    function derivatives(\n        uint256 t,\n        uint256 v,\n        uint256 sp,\n        uint256 st\n    ) internal pure returns (uint256 d1, uint256 d2) {\n        require(sp > 0, \"!sp\");\n        require(st > 0, \"!st\");\n\n        uint256 sigma = ((v**2) / 2);\n        uint256 sigmaB = 1e36;\n\n        uint256 sig = (((1e18 * sigma) / sigmaB) * t) / 365;\n\n        uint256 sSQRT = (v * Math.sqrt2((1e18 * t) / 365)) / 1e9;\n        require(sSQRT > 0, \"!sSQRT\");\n\n        d1 = (1e18 * Math.ln((Math.FIXED_1 * sp) / st)) / Math.FIXED_1;\n        d1 = ((d1 + sig) * 1e18) / sSQRT;\n        d2 = d1 - sSQRT;\n    }\n\n    /**\n     * @notice Calculates the current underlying price, annualized volatility, and days until expiry\n     * as parameters to black scholes calculations\n     * @param expiryTimestamp is the unix timestamp of expiry\n     * @return sp is the underlying\n     * @return v is the volatility\n     * @return t is the days until expiry\n     */\n    function blackScholesParams(uint256 spotPrice, uint256 expiryTimestamp)\n        private\n        view\n        returns (\n            uint256 sp,\n            uint256 v,\n            uint256 t\n        )\n    {\n        // chainlink oracle returns crypto / usd pairs with 8 decimals, like otoken strike price\n        sp = (spotPrice * (10**8)) / (10**priceOracleDecimals);\n        // annualized vol * 10 ** 8 because delta expects 18 decimals\n        // and annualizedVol is 8 decimals\n        v = volatilityOracle.annualizedVol(optionId) * (10**10);\n        t = (expiryTimestamp - block.timestamp) / (1 days);\n    }\n\n    /**\n     * @notice Calculates the underlying assets price\n     */\n    function getUnderlyingPrice() external view returns (uint256 price) {\n        price = priceOracle.latestAnswer();\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n    function decimals() external view returns (uint256 _decimals);\n\n    function latestAnswer() external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/IManualVolatilityOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IManualVolatilityOracle {\n    function vol(bytes32 optionId)\n        external\n        view\n        returns (uint256 standardDeviation);\n\n    function annualizedVol(bytes32 optionId)\n        external\n        view\n        returns (uint256 annualStdev);\n\n    function setAnnualizedVol(\n        bytes32[] calldata optionIds,\n        uint256[] calldata newAnnualizedVols\n    ) external;\n}\n"
    },
    "contracts/libs/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary Math {\n    uint256 constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 constant SQRT_1 = 13043817825332782212;\n    uint256 constant LNX = 3988425491;\n    uint256 constant LOG_10_2 = 3010299957;\n    uint256 constant LOG_E_2 = 6931471806;\n    uint256 constant BASE = 1e10;\n\n    // solhint-disable-next-line\n    // Credit to Ryan Hendricks, https://github.com/RyanHendricks/Black-Scholes-Solidity/blob/master/contracts/BlackScholesEstimate.sol\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n    function stddev(uint256[] memory numbers)\n        internal\n        pure\n        returns (uint256 sd)\n    {\n        uint256 sum = 0;\n        uint256 i;\n        for (i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length; // Integral value; float not supported in Solidity\n        sum = 0;\n        for (i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean)**2;\n        }\n        sd = sqrt(sum / (numbers.length - 1)); //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n    function sqrt2(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    // solhint-disable-next-line\n    // Credit to Paul Razvan Berg https://github.com/hifi-finance/prb-math/blob/main/contracts/PRBMath.sol\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1; // Seven iterations should be enough\n        uint256 roundedDownResult = x / result;\n        return result >= roundedDownResult ? roundedDownResult : result;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res =\n                (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\n                0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res =\n                (res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\n                0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res =\n                (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\n                0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res =\n                (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\n                0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res =\n                (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\n                0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res =\n                (res * 0x00960aadc109e7a3bf4578099615711d7) /\n                0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res =\n                (res * 0x0002bf84208204f5977f9a8cf01fdc307) /\n                0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (uint256(1) << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function ln(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = 127; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += uint256(1) << (i - 1);\n                }\n            }\n        }\n\n        return (res * LOG_E_2) / BASE;\n    }\n\n    /**\n     * @notice Takes the absolute value of a given number\n     * @dev Helper function\n     * @param _number The specified number\n     * @return The absolute value of the number\n     */\n    function abs(int256 _number) public pure returns (uint256) {\n        return _number < 0 ? uint256(_number * (-1)) : uint256(_number);\n    }\n\n    function ncdf(uint256 x) internal pure returns (uint256) {\n        int256 t1 = int256(1e7 + ((2316419 * x) / FIXED_1));\n        uint256 exp = ((x / 2) * x) / FIXED_1;\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\n        uint256 prob = uint256(\n            (d *\n                (3193815 +\n                    ((-3565638 +\n                        ((17814780 +\n                            ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\n                            t1) * 1e7) /\n                        t1) * 1e7) /\n                    t1) *\n                1e7) / t1\n        );\n        if (x > 0) prob = 1e14 - prob;\n        return prob;\n    }\n\n    function cdf(int256 x) internal pure returns (uint256) {\n        int256 t1 = int256(1e7 + int256((2316419 * abs(x)) / FIXED_1));\n        uint256 exp = uint256((x / 2) * x) / FIXED_1;\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\n        uint256 prob = uint256(\n            (d *\n                (3193815 +\n                    ((-3565638 +\n                        ((17814780 +\n                            ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\n                            t1) * 1e7) /\n                        t1) * 1e7) /\n                    t1) *\n                1e7) / t1\n        );\n        if (x > 0) prob = 1e14 - prob;\n        return prob;\n    }\n}\n"
    },
    "contracts/EasyAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./interfaces/AllowListVerifier.sol\";\nimport \"./libs/IterableOrderedOrderSet.sol\";\nimport \"./libs/IdToAddressBiMap.sol\";\n\n//AVAX: 0xb5D00F83680ea5E078e911995c64b43Fbfd1eE61\ncontract EasyAuction is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using IterableOrderedOrderSet for IterableOrderedOrderSet.Data;\n    using IterableOrderedOrderSet for bytes32;\n    using IdToAddressBiMap for IdToAddressBiMap.Data;\n\n    modifier atStageOrderPlacement(uint256 auctionId) {\n        require(\n            block.timestamp < auctionData[auctionId].auctionEndDate,\n            \"no longer in order placement phase\"\n        );\n        _;\n    }\n\n    modifier atStageOrderPlacementAndCancelation(uint256 auctionId) {\n        require(\n            block.timestamp < auctionData[auctionId].orderCancellationEndDate,\n            \"no longer in order placement and cancelation phase\"\n        );\n        _;\n    }\n\n    modifier atStageSolutionSubmission(uint256 auctionId) {\n        {\n            uint256 auctionEndDate = auctionData[auctionId].auctionEndDate;\n            require(\n                auctionEndDate != 0 &&\n                    block.timestamp >= auctionEndDate &&\n                    auctionData[auctionId].clearingPriceOrder == bytes32(0),\n                \"Auction not in solution submission phase\"\n            );\n        }\n        _;\n    }\n\n    modifier atStageFinished(uint256 auctionId) {\n        require(\n            auctionData[auctionId].clearingPriceOrder != bytes32(0),\n            \"Auction not yet finished\"\n        );\n        _;\n    }\n\n    event NewSellOrder(\n        uint256 indexed auctionId,\n        uint64 indexed userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    );\n    event CancellationSellOrder(\n        uint256 indexed auctionId,\n        uint64 indexed userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    );\n    event ClaimedFromOrder(\n        uint256 indexed auctionId,\n        uint64 indexed userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    );\n    event NewUser(uint64 indexed userId, address indexed userAddress);\n    event NewAuction(\n        uint256 indexed auctionId,\n        IERC20 indexed _auctioningToken,\n        IERC20 indexed _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint64 userId,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        address allowListContract,\n        bytes allowListData\n    );\n    event AuctionCleared(\n        uint256 indexed auctionId,\n        uint96 soldAuctioningTokens,\n        uint96 soldBiddingTokens,\n        bytes32 clearingPriceOrder\n    );\n    event UserRegistration(address indexed user, uint64 userId);\n\n    struct AuctionData {\n        IERC20 auctioningToken;\n        IERC20 biddingToken;\n        uint256 orderCancellationEndDate;\n        uint256 auctionEndDate;\n        bytes32 initialAuctionOrder;\n        uint256 minimumBiddingAmountPerOrder;\n        uint256 interimSumBidAmount;\n        bytes32 interimOrder;\n        bytes32 clearingPriceOrder;\n        uint96 volumeClearingPriceOrder;\n        bool minFundingThresholdNotReached;\n        bool isAtomicClosureAllowed;\n        uint256 feeNumerator;\n        uint256 minFundingThreshold;\n    }\n    mapping(uint256 => IterableOrderedOrderSet.Data) internal sellOrders;\n    mapping(uint256 => AuctionData) public auctionData;\n    mapping(uint256 => address) public auctionAccessManager;\n    mapping(uint256 => bytes) public auctionAccessData;\n\n    IdToAddressBiMap.Data private registeredUsers;\n    uint64 public numUsers;\n    uint256 public auctionCounter;\n\n    uint256 public feeNumerator = 0;\n    uint256 public constant FEE_DENOMINATOR = 1000;\n    uint64 public feeReceiverUserId = 1;\n\n    function setFeeParameters(\n        uint256 newFeeNumerator,\n        address newfeeReceiverAddress\n    ) public onlyOwner() {\n        require(\n            newFeeNumerator <= 15,\n            \"Fee is not allowed to be set higher than 1.5%\"\n        );\n        // caution: for currently running auctions, the feeReceiverUserId is changing as well.\n        feeReceiverUserId = getUserId(newfeeReceiverAddress);\n        feeNumerator = newFeeNumerator;\n    }\n\n    // @dev: function to intiate a new auction\n    // Warning: In case the auction is expected to raise more than\n    // 2^96 units of the biddingToken, don't start the auction, as\n    // it will not be settlable. This corresponds to about 79\n    // billion DAI.\n    //\n    // Prices between biddingToken and auctioningToken are expressed by a\n    // fraction whose components are stored as uint96.\n    function initiateAuction(\n        IERC20 _auctioningToken,\n        IERC20 _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes memory accessManagerContractData\n    ) public returns (uint256) {\n        // withdraws sellAmount + fees\n        _auctioningToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            (_auctionedSellAmount * (FEE_DENOMINATOR + feeNumerator)) /\n                FEE_DENOMINATOR\n        );\n        require(_auctionedSellAmount > 0, \"cannot auction zero tokens\");\n        require(_minBuyAmount > 0, \"tokens cannot be auctioned for free\");\n        require(\n            minimumBiddingAmountPerOrder > 0,\n            \"minimumBiddingAmountPerOrder is not allowed to be zero\"\n        );\n        require(\n            orderCancellationEndDate <= auctionEndDate,\n            \"time periods are not configured correctly\"\n        );\n        require(\n            auctionEndDate > block.timestamp,\n            \"auction end date must be in the future\"\n        );\n        auctionCounter++;\n        sellOrders[auctionCounter].initializeEmptyList();\n        uint64 userId = getUserId(msg.sender);\n        auctionData[auctionCounter] = AuctionData(\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            IterableOrderedOrderSet.encodeOrder(\n                userId,\n                _minBuyAmount,\n                _auctionedSellAmount\n            ),\n            minimumBiddingAmountPerOrder,\n            0,\n            IterableOrderedOrderSet.QUEUE_START,\n            bytes32(0),\n            0,\n            false,\n            isAtomicClosureAllowed,\n            feeNumerator,\n            minFundingThreshold\n        );\n        auctionAccessManager[auctionCounter] = accessManagerContract;\n        auctionAccessData[auctionCounter] = accessManagerContractData;\n        emit NewAuction(\n            auctionCounter,\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            userId,\n            _auctionedSellAmount,\n            _minBuyAmount,\n            minimumBiddingAmountPerOrder,\n            minFundingThreshold,\n            accessManagerContract,\n            accessManagerContractData\n        );\n        return auctionCounter;\n    }\n\n    function placeSellOrders(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n            _placeSellOrders(\n                auctionId,\n                _minBuyAmounts,\n                _sellAmounts,\n                _prevSellOrders,\n                allowListCallData,\n                msg.sender\n            );\n    }\n\n    function placeSellOrdersOnBehalf(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData,\n        address orderSubmitter\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n            _placeSellOrders(\n                auctionId,\n                _minBuyAmounts,\n                _sellAmounts,\n                _prevSellOrders,\n                allowListCallData,\n                orderSubmitter\n            );\n    }\n\n    function _placeSellOrders(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData,\n        address orderSubmitter\n    ) internal returns (uint64 userId) {\n        {\n            address allowListManager = auctionAccessManager[auctionId];\n            if (allowListManager != address(0)) {\n                require(\n                    AllowListVerifier(allowListManager).isAllowed(\n                        orderSubmitter,\n                        auctionId,\n                        allowListCallData\n                    ) == AllowListVerifierHelper.MAGICVALUE,\n                    \"user not allowed to place order\"\n                );\n            }\n        }\n        {\n            (\n                ,\n                uint96 buyAmountOfInitialAuctionOrder,\n                uint96 sellAmountOfInitialAuctionOrder\n            ) = auctionData[auctionId].initialAuctionOrder.decodeOrder();\n            for (uint256 i = 0; i < _minBuyAmounts.length; i++) {\n                require(\n                    _minBuyAmounts[i] * buyAmountOfInitialAuctionOrder <\n                        sellAmountOfInitialAuctionOrder * _sellAmounts[i],\n                    \"limit price not better than mimimal offer\"\n                );\n            }\n        }\n        uint256 sumOfSellAmounts = 0;\n        userId = getUserId(orderSubmitter);\n        uint256 minimumBiddingAmountPerOrder = auctionData[auctionId]\n        .minimumBiddingAmountPerOrder;\n        for (uint256 i = 0; i < _minBuyAmounts.length; i++) {\n            require(\n                _minBuyAmounts[i] > 0,\n                \"_minBuyAmounts must be greater than 0\"\n            );\n            // orders should have a minimum bid size in order to limit the gas\n            // required to compute the final price of the auction.\n            require(\n                _sellAmounts[i] > minimumBiddingAmountPerOrder,\n                \"order too small\"\n            );\n            if (\n                sellOrders[auctionId].insert(\n                    IterableOrderedOrderSet.encodeOrder(\n                        userId,\n                        _minBuyAmounts[i],\n                        _sellAmounts[i]\n                    ),\n                    _prevSellOrders[i]\n                )\n            ) {\n                sumOfSellAmounts += _sellAmounts[i];\n                emit NewSellOrder(\n                    auctionId,\n                    userId,\n                    _minBuyAmounts[i],\n                    _sellAmounts[i]\n                );\n            }\n        }\n        auctionData[auctionId].biddingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            sumOfSellAmounts\n        ); //[1]\n    }\n\n    function cancelSellOrders(uint256 auctionId, bytes32[] memory _sellOrders)\n        public\n        atStageOrderPlacementAndCancelation(auctionId)\n    {\n        uint64 userId = getUserId(msg.sender);\n        uint256 claimableAmount = 0;\n        for (uint256 i = 0; i < _sellOrders.length; i++) {\n            // Note: we keep the back pointer of the deleted element so that\n            // it can be used as a reference point to insert a new node.\n            bool success = sellOrders[auctionId].removeKeepHistory(\n                _sellOrders[i]\n            );\n            if (success) {\n                (\n                    uint64 userIdOfIter,\n                    uint96 buyAmountOfIter,\n                    uint96 sellAmountOfIter\n                ) = _sellOrders[i].decodeOrder();\n                require(\n                    userIdOfIter == userId,\n                    \"Only the user can cancel his orders\"\n                );\n                claimableAmount += sellAmountOfIter;\n                emit CancellationSellOrder(\n                    auctionId,\n                    userId,\n                    buyAmountOfIter,\n                    sellAmountOfIter\n                );\n            }\n        }\n        auctionData[auctionId].biddingToken.safeTransfer(\n            msg.sender,\n            claimableAmount\n        ); //[2]\n    }\n\n    function precalculateSellAmountSum(\n        uint256 auctionId,\n        uint256 iterationSteps\n    ) public atStageSolutionSubmission(auctionId) {\n        (, , uint96 auctioneerSellAmount) = auctionData[auctionId]\n        .initialAuctionOrder\n        .decodeOrder();\n        uint256 sumBidAmount = auctionData[auctionId].interimSumBidAmount;\n        bytes32 iterOrder = auctionData[auctionId].interimOrder;\n\n        for (uint256 i = 0; i < iterationSteps; i++) {\n            iterOrder = sellOrders[auctionId].next(iterOrder);\n            (, , uint96 _sellAmountOfIter) = iterOrder.decodeOrder();\n            sumBidAmount += _sellAmountOfIter;\n        }\n\n        require(\n            iterOrder != IterableOrderedOrderSet.QUEUE_END,\n            \"reached end of order list\"\n        );\n\n        // it is checked that not too many iteration steps were taken:\n        // require that the sum of SellAmounts times the price of the last order\n        // is not more than initially sold amount\n        (, uint96 buyAmountOfIter, uint96 sellAmountOfIter) = iterOrder\n        .decodeOrder();\n        require(\n            sumBidAmount * buyAmountOfIter <\n                auctioneerSellAmount * sellAmountOfIter,\n            \"too many orders summed up\"\n        );\n\n        auctionData[auctionId].interimSumBidAmount = sumBidAmount;\n        auctionData[auctionId].interimOrder = iterOrder;\n    }\n\n    function settleAuctionAtomically(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmount,\n        uint96[] memory _sellAmount,\n        bytes32[] memory _prevSellOrder,\n        bytes calldata allowListCallData\n    ) public atStageSolutionSubmission(auctionId) {\n        require(\n            auctionData[auctionId].isAtomicClosureAllowed,\n            \"not allowed to settle auction atomically\"\n        );\n        require(\n            _minBuyAmount.length == 1 && _sellAmount.length == 1,\n            \"Only one order can be placed atomically\"\n        );\n        uint64 userId = getUserId(msg.sender);\n        require(\n            auctionData[auctionId].interimOrder.smallerThan(\n                IterableOrderedOrderSet.encodeOrder(\n                    userId,\n                    _minBuyAmount[0],\n                    _sellAmount[0]\n                )\n            ),\n            \"precalculateSellAmountSum is already too advanced\"\n        );\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmount,\n            _sellAmount,\n            _prevSellOrder,\n            allowListCallData,\n            msg.sender\n        );\n        settleAuction(auctionId);\n    }\n\n    // @dev function settling the auction and calculating the price\n    function settleAuction(uint256 auctionId)\n        public\n        atStageSolutionSubmission(auctionId)\n        returns (bytes32 clearingOrder)\n    {\n        (\n            uint64 auctioneerId,\n            uint96 minAuctionedBuyAmount,\n            uint96 fullAuctionedAmount\n        ) = auctionData[auctionId].initialAuctionOrder.decodeOrder();\n\n        uint256 currentBidSum = auctionData[auctionId].interimSumBidAmount;\n        bytes32 currentOrder = auctionData[auctionId].interimOrder;\n        uint256 buyAmountOfIter;\n        uint256 sellAmountOfIter;\n        uint96 fillVolumeOfAuctioneerOrder = fullAuctionedAmount;\n        // Sum order up, until fullAuctionedAmount is fully bought or queue end is reached\n        do {\n            bytes32 nextOrder = sellOrders[auctionId].next(currentOrder);\n            if (nextOrder == IterableOrderedOrderSet.QUEUE_END) {\n                break;\n            }\n            currentOrder = nextOrder;\n            (, buyAmountOfIter, sellAmountOfIter) = currentOrder.decodeOrder();\n            currentBidSum += sellAmountOfIter;\n        } while (\n            currentBidSum * buyAmountOfIter <\n                fullAuctionedAmount * sellAmountOfIter\n        );\n\n        if (\n            currentBidSum > 0 &&\n            currentBidSum * buyAmountOfIter >=\n            fullAuctionedAmount * sellAmountOfIter\n        ) {\n            // All considered/summed orders are sufficient to close the auction fully\n            // at price between current and previous orders.\n            uint256 uncoveredBids = currentBidSum -\n                (fullAuctionedAmount * sellAmountOfIter) /\n                buyAmountOfIter;\n\n            if (sellAmountOfIter >= uncoveredBids) {\n                //[13]\n                // Auction fully filled via partial match of currentOrder\n                uint256 sellAmountClearingOrder = sellAmountOfIter -\n                    uncoveredBids;\n                auctionData[auctionId]\n                .volumeClearingPriceOrder = sellAmountClearingOrder.toUint96();\n                currentBidSum -= uncoveredBids;\n                clearingOrder = currentOrder;\n            } else {\n                //[14]\n                // Auction fully filled via price strictly between currentOrder and the order\n                // immediately before. For a proof, see the security-considerations.md\n                currentBidSum -= sellAmountOfIter;\n                clearingOrder = IterableOrderedOrderSet.encodeOrder(\n                    0,\n                    fullAuctionedAmount,\n                    currentBidSum.toUint96()\n                );\n            }\n        } else {\n            // All considered/summed orders are not sufficient to close the auction fully at price of last order //[18]\n            // Either a higher price must be used or auction is only partially filled\n\n            if (currentBidSum > minAuctionedBuyAmount) {\n                //[15]\n                // Price higher than last order would fill the auction\n                clearingOrder = IterableOrderedOrderSet.encodeOrder(\n                    0,\n                    fullAuctionedAmount,\n                    currentBidSum.toUint96()\n                );\n            } else {\n                //[16]\n                // Even at the initial auction price, the auction is partially filled\n                clearingOrder = IterableOrderedOrderSet.encodeOrder(\n                    0,\n                    fullAuctionedAmount,\n                    minAuctionedBuyAmount\n                );\n                fillVolumeOfAuctioneerOrder = ((currentBidSum *\n                    fullAuctionedAmount) / minAuctionedBuyAmount)\n                .toUint96();\n            }\n        }\n        auctionData[auctionId].clearingPriceOrder = clearingOrder;\n\n        if (auctionData[auctionId].minFundingThreshold > currentBidSum) {\n            auctionData[auctionId].minFundingThresholdNotReached = true;\n        }\n        processFeesAndAuctioneerFunds(\n            auctionId,\n            fillVolumeOfAuctioneerOrder,\n            auctioneerId,\n            fullAuctionedAmount\n        );\n        emit AuctionCleared(\n            auctionId,\n            fillVolumeOfAuctioneerOrder,\n            uint96(currentBidSum),\n            clearingOrder\n        );\n        // Gas refunds\n        auctionAccessManager[auctionId] = address(0);\n        delete auctionAccessData[auctionId];\n        auctionData[auctionId].initialAuctionOrder = bytes32(0);\n        auctionData[auctionId].interimOrder = bytes32(0);\n        auctionData[auctionId].interimSumBidAmount = uint256(0);\n        auctionData[auctionId].minimumBiddingAmountPerOrder = uint256(0);\n    }\n\n    function claimFromParticipantOrder(\n        uint256 auctionId,\n        bytes32[] memory orders\n    )\n        public\n        atStageFinished(auctionId)\n        returns (\n            uint256 sumAuctioningTokenAmount,\n            uint256 sumBiddingTokenAmount\n        )\n    {\n        for (uint256 i = 0; i < orders.length; i++) {\n            // Note: we don't need to keep any information about the node since\n            // no new elements need to be inserted.\n            require(\n                sellOrders[auctionId].remove(orders[i]),\n                \"order is no longer claimable\"\n            );\n        }\n        AuctionData memory auction = auctionData[auctionId];\n        (, uint96 priceNumerator, uint96 priceDenominator) = auction\n        .clearingPriceOrder\n        .decodeOrder();\n        (uint64 userId, , ) = orders[0].decodeOrder();\n        bool minFundingThresholdNotReached = auctionData[auctionId]\n        .minFundingThresholdNotReached;\n        for (uint256 i = 0; i < orders.length; i++) {\n            (uint64 userIdOrder, uint96 buyAmount, uint96 sellAmount) = orders[\n                i\n            ]\n            .decodeOrder();\n            require(\n                userIdOrder == userId,\n                \"only allowed to claim for same user\"\n            );\n            if (minFundingThresholdNotReached) {\n                //[10]\n                sumBiddingTokenAmount += sellAmount;\n            } else {\n                //[23]\n                if (orders[i] == auction.clearingPriceOrder) {\n                    //[25]\n                    sumAuctioningTokenAmount +=\n                        (auction.volumeClearingPriceOrder * priceNumerator) /\n                        priceDenominator;\n                    sumBiddingTokenAmount =\n                        sumBiddingTokenAmount +\n                        sellAmount -\n                        auction.volumeClearingPriceOrder;\n                } else {\n                    if (orders[i].smallerThan(auction.clearingPriceOrder)) {\n                        //[17]\n                        sumAuctioningTokenAmount +=\n                            (sellAmount * priceNumerator) /\n                            priceDenominator;\n                    } else {\n                        //[24]\n                        sumBiddingTokenAmount += sellAmount;\n                    }\n                }\n            }\n            emit ClaimedFromOrder(auctionId, userId, buyAmount, sellAmount);\n        }\n        sendOutTokens(\n            auctionId,\n            sumAuctioningTokenAmount,\n            sumBiddingTokenAmount,\n            userId\n        ); //[3]\n    }\n\n    function processFeesAndAuctioneerFunds(\n        uint256 auctionId,\n        uint256 fillVolumeOfAuctioneerOrder,\n        uint64 auctioneerId,\n        uint96 fullAuctionedAmount\n    ) internal {\n        uint256 feeAmount = (fullAuctionedAmount *\n            auctionData[auctionId].feeNumerator) / FEE_DENOMINATOR; //[20]\n        if (auctionData[auctionId].minFundingThresholdNotReached) {\n            sendOutTokens(\n                auctionId,\n                fullAuctionedAmount + feeAmount,\n                0,\n                auctioneerId\n            ); //[4]\n        } else {\n            //[11]\n            (, uint96 priceNumerator, uint96 priceDenominator) = auctionData[\n                auctionId\n            ]\n            .clearingPriceOrder\n            .decodeOrder();\n            uint256 unsettledAuctionTokens = fullAuctionedAmount -\n                fillVolumeOfAuctioneerOrder;\n            uint256 auctioningTokenAmount = unsettledAuctionTokens +\n                (feeAmount * unsettledAuctionTokens) /\n                fullAuctionedAmount;\n            uint256 biddingTokenAmount = (fillVolumeOfAuctioneerOrder *\n                priceDenominator) / priceNumerator;\n            sendOutTokens(\n                auctionId,\n                auctioningTokenAmount,\n                biddingTokenAmount,\n                auctioneerId\n            ); //[5]\n            sendOutTokens(\n                auctionId,\n                (feeAmount * fillVolumeOfAuctioneerOrder) / fullAuctionedAmount,\n                0,\n                feeReceiverUserId\n            ); //[7]\n        }\n    }\n\n    function sendOutTokens(\n        uint256 auctionId,\n        uint256 auctioningTokenAmount,\n        uint256 biddingTokenAmount,\n        uint64 userId\n    ) internal {\n        address userAddress = registeredUsers.getAddressAt(userId);\n        if (auctioningTokenAmount > 0) {\n            auctionData[auctionId].auctioningToken.safeTransfer(\n                userAddress,\n                auctioningTokenAmount\n            );\n        }\n        if (biddingTokenAmount > 0) {\n            auctionData[auctionId].biddingToken.safeTransfer(\n                userAddress,\n                biddingTokenAmount\n            );\n        }\n    }\n\n    function registerUser(address user) public returns (uint64 userId) {\n        numUsers++;\n        require(\n            registeredUsers.insert(numUsers, user),\n            \"User already registered\"\n        );\n        userId = numUsers;\n        emit UserRegistration(user, userId);\n    }\n\n    function getUserId(address user) public returns (uint64 userId) {\n        if (registeredUsers.hasAddress(user)) {\n            userId = registeredUsers.getId(user);\n        } else {\n            userId = registerUser(user);\n            emit NewUser(userId, user);\n        }\n    }\n\n    function getSecondsRemainingInBatch(uint256 auctionId)\n        public\n        view\n        returns (uint256)\n    {\n        if (auctionData[auctionId].auctionEndDate < block.timestamp) {\n            return 0;\n        }\n        return auctionData[auctionId].auctionEndDate - block.timestamp;\n    }\n\n    function containsOrder(uint256 auctionId, bytes32 order)\n        public\n        view\n        returns (bool)\n    {\n        return sellOrders[auctionId].contains(order);\n    }\n}\n"
    },
    "contracts/interfaces/AllowListVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary AllowListVerifierHelper {\n    /// @dev Value returned by a call to `isAllowed` if the check\n    /// was successful. The value is defined as:\n    /// bytes4(keccak256(\"isAllowed(address,uint256,bytes)\"))\n    bytes4 internal constant MAGICVALUE = 0x19a05a7e;\n}\n\n///\n/// @dev Standardized interface for an allowList manager for easyAuction\n/// The interface was inspired by EIP-1271\ninterface AllowListVerifier {\n    /// @dev Should return whether the a specific user has access to an auction\n    /// by returning the magic value from AllowListVerifierHelper\n    function isAllowed(\n        address user,\n        uint256 auctionId,\n        bytes calldata callData\n    ) external view returns (bytes4);\n}\n"
    },
    "contracts/libs/IterableOrderedOrderSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary IterableOrderedOrderSet {\n    using IterableOrderedOrderSet for bytes32;\n\n    // represents smallest possible value for an order under comparison of fn smallerThan()\n    bytes32 internal constant QUEUE_START =\n        0x0000000000000000000000000000000000000000000000000000000000000001;\n    // represents highest possible value for an order under comparison of fn smallerThan()\n    bytes32 internal constant QUEUE_END =\n        0xffffffffffffffffffffffffffffffffffffffff000000000000000000000001;\n\n    /// The struct is used to implement a modified version of a doubly linked\n    /// list with sorted elements. The list starts from QUEUE_START to\n    /// QUEUE_END, and each node keeps track of its predecessor and successor.\n    /// Nodes can be added or removed.\n    ///\n    /// `next` and `prev` have a different role. The list is supposed to be\n    /// traversed with `next`. If `next` is empty, the node is not part of the\n    /// list. However, `prev` might be set for elements that are not in the\n    /// list, which is why it should not be used for traversing. Having a `prev`\n    /// set for elements not in the list is used to keep track of the history of\n    /// the position in the list of a removed element.\n    struct Data {\n        mapping(bytes32 => bytes32) nextMap;\n        mapping(bytes32 => bytes32) prevMap;\n    }\n\n    struct Order {\n        uint64 owner;\n        uint96 buyAmount;\n        uint96 sellAmount;\n    }\n\n    function initializeEmptyList(Data storage self) internal {\n        self.nextMap[QUEUE_START] = QUEUE_END;\n        self.prevMap[QUEUE_END] = QUEUE_START;\n    }\n\n    function isEmpty(Data storage self) internal view returns (bool) {\n        return self.nextMap[QUEUE_START] == QUEUE_END;\n    }\n\n    function insert(\n        Data storage self,\n        bytes32 elementToInsert,\n        bytes32 elementBeforeNewOne\n    ) internal returns (bool) {\n        (, , uint96 denominator) = decodeOrder(elementToInsert);\n        require(denominator != uint96(0), \"Inserting zero is not supported\");\n        require(\n            elementToInsert != QUEUE_START && elementToInsert != QUEUE_END,\n            \"Inserting element is not valid\"\n        );\n        if (contains(self, elementToInsert)) {\n            return false;\n        }\n        if (\n            elementBeforeNewOne != QUEUE_START &&\n            self.prevMap[elementBeforeNewOne] == bytes32(0)\n        ) {\n            return false;\n        }\n        if (!elementBeforeNewOne.smallerThan(elementToInsert)) {\n            return false;\n        }\n\n        // `elementBeforeNewOne` might have been removed during the time it\n        // took to the transaction calling this function to be mined, so\n        // the new order cannot be appended directly to this. We follow the\n        // history of previous links backwards until we find an element in\n        // the list from which to start our search.\n        // Note that following the link backwards returns elements that are\n        // before `elementBeforeNewOne` in sorted order.\n        while (self.nextMap[elementBeforeNewOne] == bytes32(0)) {\n            elementBeforeNewOne = self.prevMap[elementBeforeNewOne];\n        }\n\n        // `elementBeforeNewOne` belongs now to the linked list. We search the\n        // largest entry that is smaller than the element to insert.\n        bytes32 previous;\n        bytes32 current = elementBeforeNewOne;\n        do {\n            previous = current;\n            current = self.nextMap[current];\n        } while (current.smallerThan(elementToInsert));\n        // Note: previous < elementToInsert < current\n        self.nextMap[previous] = elementToInsert;\n        self.prevMap[current] = elementToInsert;\n        self.prevMap[elementToInsert] = previous;\n        self.nextMap[elementToInsert] = current;\n\n        return true;\n    }\n\n    /// The element is removed from the linked list, but the node retains\n    /// information on which predecessor it had, so that a node in the chain\n    /// can be reached by following the predecessor chain of deleted elements.\n    function removeKeepHistory(Data storage self, bytes32 elementToRemove)\n        internal\n        returns (bool)\n    {\n        if (!contains(self, elementToRemove)) {\n            return false;\n        }\n        bytes32 previousElement = self.prevMap[elementToRemove];\n        bytes32 nextElement = self.nextMap[elementToRemove];\n        self.nextMap[previousElement] = nextElement;\n        self.prevMap[nextElement] = previousElement;\n        self.nextMap[elementToRemove] = bytes32(0);\n        return true;\n    }\n\n    /// Remove an element from the chain, clearing all related storage.\n    /// Note that no elements should be inserted using as a reference point a\n    /// node deleted after calling `remove`, since an element in the `prev`\n    /// chain might be missing.\n    function remove(Data storage self, bytes32 elementToRemove)\n        internal\n        returns (bool)\n    {\n        bool result = removeKeepHistory(self, elementToRemove);\n        if (result) {\n            self.prevMap[elementToRemove] = bytes32(0);\n        }\n        return result;\n    }\n\n    function contains(Data storage self, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        if (value == QUEUE_START) {\n            return false;\n        }\n        // Note: QUEUE_END is not contained in the list since it has no\n        // successor.\n        return self.nextMap[value] != bytes32(0);\n    }\n\n    // @dev orders are ordered by\n    // 1. their price - buyAmount/sellAmount\n    // 2. by the sellAmount\n    // 3. their userId,\n    function smallerThan(bytes32 orderLeft, bytes32 orderRight)\n        internal\n        pure\n        returns (bool)\n    {\n        (\n            uint64 userIdLeft,\n            uint96 priceNumeratorLeft,\n            uint96 priceDenominatorLeft\n        ) = decodeOrder(orderLeft);\n        (\n            uint64 userIdRight,\n            uint96 priceNumeratorRight,\n            uint96 priceDenominatorRight\n        ) = decodeOrder(orderRight);\n\n        if (\n            priceNumeratorLeft * priceDenominatorRight <\n            priceNumeratorRight * priceDenominatorLeft\n        ) return true;\n        if (\n            priceNumeratorLeft * priceDenominatorRight >\n            priceNumeratorRight * priceDenominatorLeft\n        ) return false;\n\n        if (priceNumeratorLeft < priceNumeratorRight) return true;\n        if (priceNumeratorLeft > priceNumeratorRight) return false;\n        require(\n            userIdLeft != userIdRight,\n            \"user is not allowed to place same order twice\"\n        );\n        if (userIdLeft < userIdRight) {\n            return true;\n        }\n        return false;\n    }\n\n    function first(Data storage self) internal view returns (bytes32) {\n        require(!isEmpty(self), \"Trying to get first from empty set\");\n        return self.nextMap[QUEUE_START];\n    }\n\n    function next(Data storage self, bytes32 value)\n        internal\n        view\n        returns (bytes32)\n    {\n        require(value != QUEUE_END, \"Trying to get next of last element\");\n        bytes32 nextElement = self.nextMap[value];\n        require(\n            nextElement != bytes32(0),\n            \"Trying to get next of non-existent element\"\n        );\n        return nextElement;\n    }\n\n    function decodeOrder(bytes32 _orderData)\n        internal\n        pure\n        returns (\n            uint64 userId,\n            uint96 buyAmount,\n            uint96 sellAmount\n        )\n    {\n        // Note: converting to uint discards the binary digits that do not fit\n        // the type.\n        userId = uint64(uint256(_orderData) >> 192);\n        buyAmount = uint96(uint256(_orderData) >> 96);\n        sellAmount = uint96(uint256(_orderData));\n    }\n\n    function encodeOrder(\n        uint64 userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                (uint256(userId) << 192) +\n                    (uint256(buyAmount) << 96) +\n                    uint256(sellAmount)\n            );\n    }\n}\n"
    },
    "contracts/libs/IdToAddressBiMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Contract does not have test coverage, as it was nearly copied from:\n// https://github.com/gnosis/solidity-data-structures/blob/master/contracts/libraries/IdToAddressBiMap.sol\n// The only change is uint16 -> uint64\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nlibrary IdToAddressBiMap {\n    struct Data {\n        mapping(uint64 => address) idToAddress;\n        mapping(address => uint64) addressToId;\n    }\n\n    function hasId(Data storage self, uint64 id) internal view returns (bool) {\n        return self.idToAddress[id + 1] != address(0);\n    }\n\n    function hasAddress(Data storage self, address addr)\n        internal\n        view\n        returns (bool)\n    {\n        return self.addressToId[addr] != 0;\n    }\n\n    function getAddressAt(Data storage self, uint64 id)\n        internal\n        view\n        returns (address)\n    {\n        require(hasId(self, id), \"Must have ID to get Address\");\n        return self.idToAddress[id + 1];\n    }\n\n    function getId(Data storage self, address addr)\n        internal\n        view\n        returns (uint64)\n    {\n        require(hasAddress(self, addr), \"Must have Address to get ID\");\n        return self.addressToId[addr] - 1;\n    }\n\n    function insert(\n        Data storage self,\n        uint64 id,\n        address addr\n    ) internal returns (bool) {\n        require(addr != address(0), \"Cannot insert zero address\");\n        require(id != ~uint64(0), \"Cannot insert max uint64\");\n        // Ensure bijectivity of the mappings\n        if (\n            self.addressToId[addr] != 0 ||\n            self.idToAddress[id + 1] != address(0)\n        ) {\n            return false;\n        }\n        self.idToAddress[id + 1] = addr;\n        self.addressToId[addr] = id + 1;\n        return true;\n    }\n}\n"
    },
    "contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/IAddressBook.sol\";\nimport \"./interfaces/IOtoken.sol\";\nimport \"./interfaces/IMarginCalculator.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IWhitelist.sol\";\nimport \"./interfaces/IMarginPool.sol\";\nimport \"./interfaces/CalleeInterface.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./libs/MarginVault.sol\";\nimport \"./libs/Actions.sol\";\n\n/**\n * Controller Error Codes\n * C1: sender is not full pauser\n * C2: sender is not partial pauser\n * C3: callee is not a whitelisted address\n * C4: system is partially paused\n * C5: system is fully paused\n * C6: msg.sender is not authorized to run action\n * C7: invalid addressbook address\n * C8: invalid owner address\n * C9: invalid input\n * C10: fullPauser cannot be set to address zero\n * C11: partialPauser cannot be set to address zero\n * C12: can not run actions for different owners\n * C13: can not run actions on different vaults\n * C14: invalid final vault state\n * C15: can not run actions on inexistent vault\n * C16: cannot deposit long otoken from this address\n * C17: otoken is not whitelisted to be used as collateral\n * C18: otoken used as collateral is already expired\n * C19: can not withdraw an expired otoken\n * C20: cannot deposit collateral from this address\n * C21: asset is not whitelisted to be used as collateral\n * C22: can not withdraw collateral from a vault with an expired short otoken\n * C23: otoken is not whitelisted to be minted\n * C24: can not mint expired otoken\n * C25: cannot burn from this address\n * C26: can not burn expired otoken\n * C27: otoken is not whitelisted to be redeemed\n * C28: can not redeem un-expired otoken\n * C29: asset prices not finalized yet\n * C30: can't settle vault with no otoken\n * C31: can not settle vault with un-expired otoken\n * C32: can not settle undercollateralized vault\n * C33: can not liquidate vault\n * C34: can not leave less than collateral dust\n * C35: invalid vault id\n * C36: cap amount should be greater than zero\n * C37: collateral exceed naked margin cap\n */\n\n/**\n * @title Controller\n * @author Opyn Team\n * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n */\ncontract Controller is\n    IController,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using MarginVault for MarginVault.Vault;\n\n    IAddressBook public addressbook;\n    IWhitelist public whitelist;\n    IOracle public oracle;\n    IMarginCalculator public calculator;\n    IMarginPool public pool;\n\n    ///@dev scale used in MarginCalculator\n    uint256 internal constant BASE = 8;\n\n    /// @notice address that has permission to partially pause the system, where system functionality is paused\n    /// except redeem and settleVault\n    address public partialPauser;\n\n    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n    address public fullPauser;\n\n    /// @notice True if all system functionality is paused other than redeem and settle vault\n    bool public systemPartiallyPaused;\n\n    /// @notice True if all system functionality is paused\n    bool public systemFullyPaused;\n\n    /// @notice True if a call action can only be executed to a whitelisted callee\n    bool public callRestricted;\n\n    /// @dev mapping between an owner address and the number of owner address vaults\n    mapping(address => uint256) internal accountVaultCounter;\n    /// @dev mapping between an owner address and a specific vault using a vault id\n    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n    /// @dev mapping between an account owner and their approved or unapproved account operators\n    mapping(address => mapping(address => bool)) internal operators;\n\n    /******************************************************************** V2.0.0 storage upgrade ******************************************************/\n\n    /// @dev mapping to map vault by each vault type, naked margin vault should be set to 1, spread/max loss vault should be set to 0\n    mapping(address => mapping(uint256 => uint256)) internal vaultType;\n    /// @dev mapping to store the timestamp at which the vault was last updated, will be updated in every action that changes the vault state or when calling sync()\n    mapping(address => mapping(uint256 => uint256)) internal vaultLatestUpdate;\n\n    /// @dev mapping to store cap amount for naked margin vault per options collateral asset (scaled by collateral asset decimals)\n    mapping(address => uint256) internal nakedCap;\n\n    /// @dev mapping to store amount of naked margin vaults in pool\n    mapping(address => uint256) internal nakedPoolBalance;\n\n    /**\n     * @notice modifier to check if the system is not partially paused, where only redeem and settleVault is allowed\n     */\n    modifier notPartiallyPaused() {\n        _isNotPartiallyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the system is not fully paused, where no functionality is allowed\n     */\n    modifier notFullyPaused() {\n        _isNotFullyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if sender is the fullPauser address\n     */\n    modifier onlyFullPauser() {\n        require(msg.sender == fullPauser, \"C1\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the partialPauser address\n     */\n    modifier onlyPartialPauser() {\n        require(msg.sender == partialPauser, \"C2\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the account owner or an approved account operator\n     * @param _sender sender address\n     * @param _accountOwner account owner address\n     */\n    modifier onlyAuthorized(address _sender, address _accountOwner) {\n        _isAuthorized(_sender, _accountOwner);\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the called address is a whitelisted callee address\n     * @param _callee called address\n     */\n    modifier onlyWhitelistedCallee(address _callee) {\n        if (callRestricted) {\n            require(_isCalleeWhitelisted(_callee), \"C3\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice initalize the deployed contract\n     * @param _addressBook addressbook module\n     * @param _owner account owner address\n     */\n    function initialize(address _addressBook, address _owner)\n        external\n        initializer\n    {\n        require(_addressBook != address(0), \"C7\");\n        require(_owner != address(0), \"C8\");\n\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n\n        addressbook = IAddressBook(_addressBook);\n        _refreshConfigInternal();\n\n        callRestricted = true;\n    }\n\n    /**\n     * @notice send asset amount to margin pool\n     * @dev use donate() instead of direct transfer() to store the balance in assetBalance\n     * @param _asset asset address\n     * @param _amount amount to donate to pool\n     */\n    function donate(address _asset, uint256 _amount) external {\n        pool.transferToPool(_asset, msg.sender, _amount);\n\n        emit Donated(msg.sender, _asset, _amount);\n    }\n\n    /**\n     * @notice allows the partialPauser to toggle the systemPartiallyPaused variable and partially pause or partially unpause the system\n     * @dev can only be called by the partialPauser\n     * @param _partiallyPaused new boolean value to set systemPartiallyPaused to\n     */\n    function setSystemPartiallyPaused(bool _partiallyPaused)\n        external\n        onlyPartialPauser\n    {\n        require(systemPartiallyPaused != _partiallyPaused, \"C9\");\n\n        systemPartiallyPaused = _partiallyPaused;\n\n        emit SystemPartiallyPaused(systemPartiallyPaused);\n    }\n\n    /**\n     * @notice allows the fullPauser to toggle the systemFullyPaused variable and fully pause or fully unpause the system\n     * @dev can only be called by the fullyPauser\n     * @param _fullyPaused new boolean value to set systemFullyPaused to\n     */\n    function setSystemFullyPaused(bool _fullyPaused) external onlyFullPauser {\n        require(systemFullyPaused != _fullyPaused, \"C9\");\n\n        systemFullyPaused = _fullyPaused;\n\n        emit SystemFullyPaused(systemFullyPaused);\n    }\n\n    /**\n     * @notice allows the owner to set the fullPauser address\n     * @dev can only be called by the owner\n     * @param _fullPauser new fullPauser address\n     */\n    function setFullPauser(address _fullPauser) external onlyOwner {\n        require(_fullPauser != address(0), \"C10\");\n        require(fullPauser != _fullPauser, \"C9\");\n        emit FullPauserUpdated(fullPauser, _fullPauser);\n        fullPauser = _fullPauser;\n    }\n\n    /**\n     * @notice allows the owner to set the partialPauser address\n     * @dev can only be called by the owner\n     * @param _partialPauser new partialPauser address\n     */\n    function setPartialPauser(address _partialPauser) external onlyOwner {\n        require(_partialPauser != address(0), \"C11\");\n        require(partialPauser != _partialPauser, \"C9\");\n        emit PartialPauserUpdated(partialPauser, _partialPauser);\n        partialPauser = _partialPauser;\n    }\n\n    /**\n     * @notice allows the owner to toggle the restriction on whitelisted call actions and only allow whitelisted\n     * call addresses or allow any arbitrary call addresses\n     * @dev can only be called by the owner\n     * @param _isRestricted new call restriction state\n     */\n    function setCallRestriction(bool _isRestricted) external onlyOwner {\n        require(callRestricted != _isRestricted, \"C9\");\n\n        callRestricted = _isRestricted;\n\n        emit CallRestricted(callRestricted);\n    }\n\n    /**\n     * @notice allows a user to give or revoke privileges to an operator which can act on their behalf on their vaults\n     * @dev can only be updated by the vault owner\n     * @param _operator operator that the sender wants to give privileges to or revoke them from\n     * @param _isOperator new boolean value that expresses if the sender is giving or revoking privileges for _operator\n     */\n    function setOperator(address _operator, bool _isOperator) external {\n        require(operators[msg.sender][_operator] != _isOperator, \"C9\");\n\n        operators[msg.sender][_operator] = _isOperator;\n\n        emit AccountOperatorUpdated(msg.sender, _operator, _isOperator);\n    }\n\n    /**\n     * @dev updates the configuration of the controller. can only be called by the owner\n     */\n    function refreshConfiguration() external onlyOwner {\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice set cap amount for collateral asset used in naked margin\n     * @dev can only be called by owner\n     * @param _collateral collateral asset address\n     * @param _cap cap amount, should be scaled by collateral asset decimals\n     */\n    function setNakedCap(address _collateral, uint256 _cap) external onlyOwner {\n        require(_cap > 0, \"C36\");\n\n        nakedCap[_collateral] = _cap;\n\n        emit NakedCapUpdated(_collateral, _cap);\n    }\n\n    /**\n     * @notice execute a number of actions on specific vaults\n     * @dev can only be called when the system is not fully paused\n     * @param _actions array of actions arguments\n     */\n    function operate(Actions.ActionArgs[] memory _actions)\n        external\n        nonReentrant\n        notFullyPaused\n    {\n        (bool vaultUpdated, address vaultOwner, uint256 vaultId) = _runActions(\n            _actions\n        );\n        if (vaultUpdated) {\n            _verifyFinalState(vaultOwner, vaultId);\n            vaultLatestUpdate[vaultOwner][vaultId] = block.timestamp;\n        }\n    }\n\n    /**\n     * @notice sync vault latest update timestamp\n     * @dev anyone can update the latest time the vault was touched by calling this function\n     * vaultLatestUpdate will sync if the vault is well collateralized\n     * @param _owner vault owner address\n     * @param _vaultId vault id\n     */\n    function sync(address _owner, uint256 _vaultId)\n        external\n        nonReentrant\n        notFullyPaused\n    {\n        _verifyFinalState(_owner, _vaultId);\n        vaultLatestUpdate[_owner][_vaultId] = block.timestamp;\n    }\n\n    /**\n     * @notice check if a specific address is an operator for an owner account\n     * @param _owner account owner address\n     * @param _operator account operator address\n     * @return True if the _operator is an approved operator for the _owner account\n     */\n    function isOperator(address _owner, address _operator)\n        external\n        view\n        returns (bool)\n    {\n        return operators[_owner][_operator];\n    }\n\n    /**\n     * @notice returns the current controller configuration\n     * @return whitelist, the address of the whitelist module\n     * @return oracle, the address of the oracle module\n     * @return calculator, the address of the calculator module\n     * @return pool, the address of the pool module\n     */\n    function getConfiguration()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address\n        )\n    {\n        return (\n            address(whitelist),\n            address(oracle),\n            address(calculator),\n            address(pool)\n        );\n    }\n\n    /**\n     * @notice return a vault's proceeds pre or post expiry, the amount of collateral that can be removed from a vault\n     * @param _owner account owner of the vault\n     * @param _vaultId vaultId to return balances for\n     * @return amount of collateral that can be taken out\n     */\n    function getProceed(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (uint256)\n    {\n        (\n            MarginVault.Vault memory vault,\n            uint256 typeVault,\n\n        ) = getVaultWithDetails(_owner, _vaultId);\n\n        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(\n            vault,\n            typeVault\n        );\n\n        if (!isExcess) return 0;\n\n        return netValue;\n    }\n\n    /**\n     * @notice check if a vault is liquidatable in a specific round id\n     * @param _owner vault owner address\n     * @param _vaultId vault id to check\n     * @param _roundId chainlink round id to check vault status at\n     * @return isUnderCollat, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n     */\n    function isLiquidatable(\n        address _owner,\n        uint256 _vaultId,\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        (, bool isUnderCollat, uint256 price, uint256 dust) = _isLiquidatable(\n            _owner,\n            _vaultId,\n            _roundId\n        );\n        return (isUnderCollat, price, dust);\n    }\n\n    /**\n     * @notice get an oToken's payout/cash value after expiry, in the collateral asset\n     * @param _otoken oToken address\n     * @param _amount amount of the oToken to calculate the payout for, always represented in 1e8\n     * @return amount of collateral to pay out\n     */\n    function getPayout(address _otoken, uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return (calculator.getExpiredPayoutRate(_otoken) * _amount) / 10**BASE;\n    }\n\n    /**\n     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n     * strike and collateral assets at this specific expiry is available in our Oracle module\n     * @param _otoken oToken\n     */\n    function isSettlementAllowed(address _otoken) external view returns (bool) {\n        (\n            address underlying,\n            address strike,\n            address collateral,\n            uint256 expiry\n        ) = _getOtokenDetails(_otoken);\n        return _canSettleAssets(underlying, strike, collateral, expiry);\n    }\n\n    /**\n     * @dev return if underlying, strike, collateral are all allowed to be settled\n     * @param _underlying oToken underlying asset\n     * @param _strike oToken strike asset\n     * @param _collateral oToken collateral asset\n     * @param _expiry otoken expiry timestamp\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function canSettleAssets(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool) {\n        return _canSettleAssets(_underlying, _strike, _collateral, _expiry);\n    }\n\n    /**\n     * @notice get the number of vaults for a specified account owner\n     * @param _accountOwner account owner address\n     * @return number of vaults\n     */\n    function getAccountVaultCounter(address _accountOwner)\n        external\n        view\n        returns (uint256)\n    {\n        return accountVaultCounter[_accountOwner];\n    }\n\n    /**\n     * @notice check if an oToken has expired\n     * @param _otoken oToken address\n     * @return True if the otoken has expired, False if not\n     */\n    function hasExpired(address _otoken) external view returns (bool) {\n        return block.timestamp >= IOtoken(_otoken).expiryTimestamp();\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner\n     */\n    function getVault(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (MarginVault.Vault memory)\n    {\n        return (vaults[_owner][_vaultId]);\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner, vault type and the latest timestamp when the vault was updated\n     */\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\n        public\n        view\n        returns (\n            MarginVault.Vault memory,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            vaults[_owner][_vaultId],\n            vaultType[_owner][_vaultId],\n            vaultLatestUpdate[_owner][_vaultId]\n        );\n    }\n\n    /**\n     * @notice get cap amount for collateral asset\n     * @param _asset collateral asset address\n     * @return cap amount\n     */\n    function getNakedCap(address _asset) external view returns (uint256) {\n        return nakedCap[_asset];\n    }\n\n    /**\n     * @notice get amount of collateral deposited in all naked margin vaults\n     * @param _asset collateral asset address\n     * @return naked pool balance\n     */\n    function getNakedPoolBalance(address _asset)\n        external\n        view\n        returns (uint256)\n    {\n        return nakedPoolBalance[_asset];\n    }\n\n    /**\n     * @notice execute a variety of actions\n     * @dev for each action in the action array, execute the corresponding action, only one vault can be modified\n     * for all actions except SettleVault, Redeem, and Call\n     * @param _actions array of type Actions.ActionArgs[], which expresses which actions the user wants to execute\n     * @return vaultUpdated, indicates if a vault has changed\n     * @return owner, the vault owner if a vault has changed\n     * @return vaultId, the vault Id if a vault has changed\n     */\n    function _runActions(Actions.ActionArgs[] memory _actions)\n        internal\n        returns (\n            bool,\n            address,\n            uint256\n        )\n    {\n        address vaultOwner;\n        uint256 vaultId;\n        bool vaultUpdated;\n\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            // actions except Settle, Redeem, Liquidate and Call are \"Vault-updating actinos\"\n            // only allow update 1 vault in each operate call\n            if (\n                (actionType != Actions.ActionType.SettleVault) &&\n                (actionType != Actions.ActionType.Redeem) &&\n                (actionType != Actions.ActionType.Liquidate) &&\n                (actionType != Actions.ActionType.Call)\n            ) {\n                // check if this action is manipulating the same vault as all other actions, if a vault has already been updated\n                if (vaultUpdated) {\n                    require(vaultOwner == action.owner, \"C12\");\n                    require(vaultId == action.vaultId, \"C13\");\n                }\n                vaultUpdated = true;\n                vaultId = action.vaultId;\n                vaultOwner = action.owner;\n            }\n\n            if (actionType == Actions.ActionType.OpenVault) {\n                _openVault(Actions._parseOpenVaultArgs(action));\n            } else if (actionType == Actions.ActionType.DepositLongOption) {\n                _depositLong(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawLongOption) {\n                _withdrawLong(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.DepositCollateral) {\n                _depositCollateral(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawCollateral) {\n                _withdrawCollateral(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.MintShortOption) {\n                _mintOtoken(Actions._parseMintArgs(action));\n            } else if (actionType == Actions.ActionType.BurnShortOption) {\n                _burnOtoken(Actions._parseBurnArgs(action));\n            } else if (actionType == Actions.ActionType.Redeem) {\n                _redeem(Actions._parseRedeemArgs(action));\n            } else if (actionType == Actions.ActionType.SettleVault) {\n                _settleVault(Actions._parseSettleVaultArgs(action));\n            } else if (actionType == Actions.ActionType.Liquidate) {\n                _liquidate(Actions._parseLiquidateArgs(action));\n            } else if (actionType == Actions.ActionType.Call) {\n                _call(Actions._parseCallArgs(action));\n            }\n        }\n\n        return (vaultUpdated, vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice verify the vault final state after executing all actions\n     * @param _owner account owner address\n     * @param _vaultId vault id of the final vault\n     */\n    function _verifyFinalState(address _owner, uint256 _vaultId) internal view {\n        (\n            MarginVault.Vault memory vault,\n            uint256 typeVault,\n\n        ) = getVaultWithDetails(_owner, _vaultId);\n        (, bool isValidVault) = calculator.getExcessCollateral(\n            vault,\n            typeVault\n        );\n\n        require(isValidVault, \"C14\");\n    }\n\n    /**\n     * @notice open a new vault inside an account\n     * @dev only the account owner or operator can open a vault, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args OpenVaultArgs structure\n     */\n    function _openVault(Actions.OpenVaultArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        uint256 vaultId = accountVaultCounter[_args.owner] + 1;\n\n        require(_args.vaultId == vaultId, \"C15\");\n\n        // store new vault\n        accountVaultCounter[_args.owner] = vaultId;\n        vaultType[_args.owner][vaultId] = _args.vaultType;\n\n        emit VaultOpened(_args.owner, vaultId, _args.vaultType);\n    }\n\n    /**\n     * @notice deposit a long oToken into a vault\n     * @dev only the account owner or operator can deposit a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositLong(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to deposit long otoken\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"C16\"\n        );\n\n        require(whitelist.isWhitelistedOtoken(_args.asset), \"C17\");\n\n        IOtoken otoken = IOtoken(_args.asset);\n\n        require(block.timestamp < otoken.expiryTimestamp(), \"C18\");\n\n        vaults[_args.owner][_args.vaultId].addLong(\n            _args.asset,\n            _args.amount,\n            _args.index\n        );\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit LongOtokenDeposited(\n            _args.asset,\n            _args.owner,\n            _args.from,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice withdraw a long oToken from a vault\n     * @dev only the account owner or operator can withdraw a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawLong(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        IOtoken otoken = IOtoken(_args.asset);\n\n        require(block.timestamp < otoken.expiryTimestamp(), \"C19\");\n\n        vaults[_args.owner][_args.vaultId].removeLong(\n            _args.asset,\n            _args.amount,\n            _args.index\n        );\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit LongOtokenWithdrawed(\n            _args.asset,\n            _args.owner,\n            _args.to,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice deposit a collateral asset into a vault\n     * @dev only the account owner or operator can deposit collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositCollateral(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to deposit collateral\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"C20\"\n        );\n\n        require(whitelist.isWhitelistedCollateral(_args.asset), \"C21\");\n\n        (, uint256 typeVault, ) = getVaultWithDetails(\n            _args.owner,\n            _args.vaultId\n        );\n\n        if (typeVault == 1) {\n            nakedPoolBalance[_args.asset] += _args.amount;\n\n            require(\n                nakedPoolBalance[_args.asset] <= nakedCap[_args.asset],\n                \"C37\"\n            );\n        }\n\n        vaults[_args.owner][_args.vaultId].addCollateral(\n            _args.asset,\n            _args.amount,\n            _args.index\n        );\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit CollateralAssetDeposited(\n            _args.asset,\n            _args.owner,\n            _args.from,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice withdraw a collateral asset from a vault\n     * @dev only the account owner or operator can withdraw collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawCollateral(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        (\n            MarginVault.Vault memory vault,\n            uint256 typeVault,\n\n        ) = getVaultWithDetails(_args.owner, _args.vaultId);\n\n        if (_isNotEmpty(vault.shortOtokens)) {\n            IOtoken otoken = IOtoken(vault.shortOtokens[0]);\n\n            require(block.timestamp < otoken.expiryTimestamp(), \"C22\");\n        }\n\n        if (typeVault == 1) {\n            nakedPoolBalance[_args.asset] -= _args.amount;\n        }\n\n        vaults[_args.owner][_args.vaultId].removeCollateral(\n            _args.asset,\n            _args.amount,\n            _args.index\n        );\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit CollateralAssetWithdrawed(\n            _args.asset,\n            _args.owner,\n            _args.to,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice mint short oTokens from a vault which creates an obligation that is recorded in the vault\n     * @dev only the account owner or operator can mint an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _mintOtoken(Actions.MintArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        require(whitelist.isWhitelistedOtoken(_args.otoken), \"C23\");\n\n        IOtoken otoken = IOtoken(_args.otoken);\n\n        require(block.timestamp < otoken.expiryTimestamp(), \"C24\");\n\n        vaults[_args.owner][_args.vaultId].addShort(\n            _args.otoken,\n            _args.amount,\n            _args.index\n        );\n\n        otoken.mintOtoken(_args.to, _args.amount);\n\n        emit ShortOtokenMinted(\n            _args.otoken,\n            _args.owner,\n            _args.to,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice burn oTokens to reduce or remove the minted oToken obligation recorded in a vault\n     * @dev only the account owner or operator can burn an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _burnOtoken(Actions.BurnArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        // check that vault id is valid for this vault owner\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n        // only allow vault owner or vault operator to burn otoken\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"C25\"\n        );\n\n        IOtoken otoken = IOtoken(_args.otoken);\n\n        // do not allow burning expired otoken\n        require(block.timestamp < otoken.expiryTimestamp(), \"C26\");\n\n        // remove otoken from vault\n        vaults[_args.owner][_args.vaultId].removeShort(\n            _args.otoken,\n            _args.amount,\n            _args.index\n        );\n\n        // burn otoken\n        otoken.burnOtoken(_args.from, _args.amount);\n\n        emit ShortOtokenBurned(\n            _args.otoken,\n            _args.owner,\n            _args.from,\n            _args.vaultId,\n            _args.amount\n        );\n    }\n\n    /**\n     * @notice redeem an oToken after expiry, receiving the payout of the oToken in the collateral asset\n     * @dev cannot be called when system is fullyPaused\n     * @param _args RedeemArgs structure\n     */\n    function _redeem(Actions.RedeemArgs memory _args) internal {\n        IOtoken otoken = IOtoken(_args.otoken);\n\n        // check that otoken to redeem is whitelisted\n        require(whitelist.isWhitelistedOtoken(_args.otoken), \"C27\");\n\n        (\n            address collateral,\n            address underlying,\n            address strike,\n            uint256 expiry\n        ) = _getOtokenDetails(address(otoken));\n\n        // only allow redeeming expired otoken\n        require(block.timestamp >= expiry, \"C28\");\n\n        require(\n            _canSettleAssets(underlying, strike, collateral, expiry),\n            \"C29\"\n        );\n\n        uint256 payout = getPayout(_args.otoken, _args.amount);\n\n        otoken.burnOtoken(msg.sender, _args.amount);\n\n        pool.transferToUser(collateral, _args.receiver, payout);\n\n        emit Redeem(\n            _args.otoken,\n            msg.sender,\n            _args.receiver,\n            collateral,\n            _args.amount,\n            payout\n        );\n    }\n\n    /**\n     * @notice settle a vault after expiry, removing the net proceeds/collateral after both long and short oToken payouts have settled\n     * @dev deletes a vault of vaultId after net proceeds/collateral is removed, cannot be called when system is fullyPaused\n     * @param _args SettleVaultArgs structure\n     */\n    function _settleVault(Actions.SettleVaultArgs memory _args)\n        internal\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        (\n            MarginVault.Vault memory vault,\n            uint256 typeVault,\n\n        ) = getVaultWithDetails(_args.owner, _args.vaultId);\n\n        IOtoken otoken;\n\n        // new scope to avoid stack too deep error\n        // check if there is short or long otoken in vault\n        // do not allow settling vault that have no short or long otoken\n        // if there is a long otoken, burn it\n        // store otoken address outside of this scope\n        {\n            bool hasShort = _isNotEmpty(vault.shortOtokens);\n            bool hasLong = _isNotEmpty(vault.longOtokens);\n\n            require(hasShort || hasLong, \"C30\");\n\n            otoken = hasShort\n                ? IOtoken(vault.shortOtokens[0])\n                : IOtoken(vault.longOtokens[0]);\n\n            if (hasLong) {\n                IOtoken longOtoken = IOtoken(vault.longOtokens[0]);\n\n                longOtoken.burnOtoken(address(pool), vault.longAmounts[0]);\n            }\n        }\n\n        (\n            address collateral,\n            address underlying,\n            address strike,\n            uint256 expiry\n        ) = _getOtokenDetails(address(otoken));\n\n        // do not allow settling vault with un-expired otoken\n        require(block.timestamp >= expiry, \"C31\");\n        require(\n            _canSettleAssets(underlying, strike, collateral, expiry),\n            \"C29\"\n        );\n\n        (uint256 payout, bool isValidVault) = calculator.getExcessCollateral(\n            vault,\n            typeVault\n        );\n\n        // require that vault is valid (has excess collateral) before settling\n        // to avoid allowing settling undercollateralized naked margin vault\n        require(isValidVault, \"C32\");\n\n        delete vaults[_args.owner][_args.vaultId];\n\n        if (typeVault == 1) {\n            nakedPoolBalance[collateral] -= payout;\n        }\n\n        pool.transferToUser(collateral, _args.to, payout);\n\n        uint256 vaultId = _args.vaultId;\n        address payoutRecipient = _args.to;\n\n        emit VaultSettled(\n            _args.owner,\n            address(otoken),\n            payoutRecipient,\n            payout,\n            vaultId,\n            typeVault\n        );\n    }\n\n    /**\n     * @notice liquidate naked margin vault\n     * @dev can liquidate different vaults id in the same operate() call\n     * @param _args liquidation action arguments struct\n     */\n    function _liquidate(Actions.LiquidateArgs memory _args)\n        internal\n        notPartiallyPaused\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"C35\");\n\n        // check if vault is undercollateralized\n        // the price is the amount of collateral asset to pay per 1 repaid debt(otoken)\n        // collateralDust is the minimum amount of collateral that can be left in the vault when a partial liquidation occurs\n        (\n            MarginVault.Vault memory vault,\n            bool isUnderCollat,\n            uint256 price,\n            uint256 collateralDust\n        ) = _isLiquidatable(_args.owner, _args.vaultId, _args.roundId);\n\n        require(isUnderCollat, \"C33\");\n\n        // amount of collateral to offer to liquidator\n        uint256 collateralToSell = (_args.amount * price) / 1e8;\n\n        // if vault is partially liquidated (amount of short otoken is still greater than zero)\n        // make sure remaining collateral amount is greater than dust amount\n        if (vault.shortAmounts[0] - _args.amount > 0) {\n            require(\n                vault.collateralAmounts[0] - collateralToSell >= collateralDust,\n                \"C34\"\n            );\n        }\n\n        // burn short otoken from liquidator address, index of short otoken hardcoded at 0\n        // this should always work, if vault have no short otoken, it will not reach this step\n        IOtoken(vault.shortOtokens[0]).burnOtoken(msg.sender, _args.amount);\n\n        // decrease amount of collateral in liquidated vault, index of collateral to decrease is hardcoded at 0\n        vaults[_args.owner][_args.vaultId].removeCollateral(\n            vault.collateralAssets[0],\n            collateralToSell,\n            0\n        );\n\n        // decrease amount of short otoken in liquidated vault, index of short otoken to decrease is hardcoded at 0\n        vaults[_args.owner][_args.vaultId].removeShort(\n            vault.shortOtokens[0],\n            _args.amount,\n            0\n        );\n\n        // decrease internal naked margin collateral amount\n        nakedPoolBalance[vault.collateralAssets[0]] -= collateralToSell;\n\n        pool.transferToUser(\n            vault.collateralAssets[0],\n            _args.receiver,\n            collateralToSell\n        );\n\n        emit VaultLiquidated(\n            msg.sender,\n            _args.receiver,\n            _args.owner,\n            price,\n            _args.roundId,\n            collateralToSell,\n            _args.amount,\n            _args.vaultId\n        );\n    }\n\n    /**\n     * @notice execute arbitrary calls\n     * @dev cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args Call action\n     */\n    function _call(Actions.CallArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyWhitelistedCallee(_args.callee)\n    {\n        CalleeInterface(_args.callee).callFunction(\n            payable(msg.sender),\n            _args.data\n        );\n\n        emit CallExecuted(msg.sender, _args.callee, _args.data);\n    }\n\n    /**\n     * @notice check if a vault id is valid for a given account owner address\n     * @param _accountOwner account owner address\n     * @param _vaultId vault id to check\n     * @return True if the _vaultId is valid, False if not\n     */\n    function _checkVaultId(address _accountOwner, uint256 _vaultId)\n        internal\n        view\n        returns (bool)\n    {\n        return ((_vaultId > 0) &&\n            (_vaultId <= accountVaultCounter[_accountOwner]));\n    }\n\n    function _isNotEmpty(address[] memory _array) internal pure returns (bool) {\n        return (_array.length > 0) && (_array[0] != address(0));\n    }\n\n    /**\n     * @dev check if the system is not in a partiallyPaused state\n     */\n    function _isNotPartiallyPaused() internal view {\n        require(!systemPartiallyPaused, \"C4\");\n    }\n\n    /**\n     * @dev check if the system is not in an fullyPaused state\n     */\n    function _isNotFullyPaused() internal view {\n        require(!systemFullyPaused, \"C5\");\n    }\n\n    /**\n     * @dev check if the sender is an authorized operator\n     * @param _sender msg.sender\n     * @param _accountOwner owner of a vault\n     */\n    function _isAuthorized(address _sender, address _accountOwner)\n        internal\n        view\n    {\n        require(\n            (_sender == _accountOwner) || (operators[_accountOwner][_sender]),\n            \"C6\"\n        );\n    }\n\n    /**\n     * @notice return if a callee address is whitelisted or not\n     * @param _callee callee address\n     * @return True if callee address is whitelisted, False if not\n     */\n    function _isCalleeWhitelisted(address _callee)\n        internal\n        view\n        returns (bool)\n    {\n        return whitelist.isWhitelistedCallee(_callee);\n    }\n\n    /**\n     * @notice check if a vault is liquidatable in a specific round id\n     * @param _owner vault owner address\n     * @param _vaultId vault id to check\n     * @param _roundId chainlink round id to check vault status at\n     * @return vault struct, isLiquidatable, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n     */\n    function _isLiquidatable(\n        address _owner,\n        uint256 _vaultId,\n        uint256 _roundId\n    )\n        internal\n        view\n        returns (\n            MarginVault.Vault memory,\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        (\n            MarginVault.Vault memory vault,\n            uint256 typeVault,\n            uint256 latestUpdateTimestamp\n        ) = getVaultWithDetails(_owner, _vaultId);\n        (bool isUnderCollat, uint256 price, uint256 collateralDust) = calculator\n        .isLiquidatable(vault, typeVault, latestUpdateTimestamp, _roundId);\n\n        return (vault, isUnderCollat, price, collateralDust);\n    }\n\n    /**\n     * @dev get otoken detail, from both otoken versions\n     */\n    function _getOtokenDetails(address _otoken)\n        internal\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256\n        )\n    {\n        IOtoken otoken = IOtoken(_otoken);\n        try otoken.getOtokenDetails() returns (\n            address collateral,\n            address underlying,\n            address strike,\n            uint256,\n            uint256 expiry,\n            bool\n        ) {\n            return (collateral, underlying, strike, expiry);\n        } catch {\n            return (\n                otoken.collateralAsset(),\n                otoken.underlyingAsset(),\n                otoken.strikeAsset(),\n                otoken.expiryTimestamp()\n            );\n        }\n    }\n\n    /**\n     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n     * strike and collateral assets at this specific expiry is available in our Oracle module\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function _canSettleAssets(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) internal view returns (bool) {\n        return\n            oracle.isDisputePeriodOver(_underlying, _expiry) &&\n            oracle.isDisputePeriodOver(_strike, _expiry) &&\n            oracle.isDisputePeriodOver(_collateral, _expiry);\n    }\n\n    /**\n     * @dev updates the internal configuration of the controller\n     */\n    function _refreshConfigInternal() internal {\n        whitelist = IWhitelist(addressbook.getWhitelist());\n        oracle = IOracle(addressbook.getOracle());\n        calculator = IMarginCalculator(addressbook.getMarginCalculator());\n        pool = IMarginPool(addressbook.getMarginPool());\n    }\n}\n"
    },
    "contracts/interfaces/IAddressBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IAddressBook {\n    function getOtokenImpl() external view returns (address);\n\n    function getOtokenFactory() external view returns (address);\n\n    function getWhitelist() external view returns (address);\n\n    function getController() external view returns (address);\n\n    function getOracle() external view returns (address);\n\n    function getMarginPool() external view returns (address);\n\n    function getMarginCalculator() external view returns (address);\n\n    function getLiquidationManager() external view returns (address);\n\n    function getAddress(bytes32 _id) external view returns (address);\n\n    function setOtokenImpl(address _otokenImpl) external;\n\n    function setOtokenFactory(address _factory) external;\n\n    function setOracleImpl(address _otokenImpl) external;\n\n    function setWhitelist(address _whitelist) external;\n\n    function setController(address _controller) external;\n\n    function setMarginPool(address _marginPool) external;\n\n    function setMarginCalculator(address _calculator) external;\n\n    function setLiquidationManager(address _liquidationManager) external;\n\n    function setAddress(bytes32 _id, address _newImpl) external;\n}\n"
    },
    "contracts/interfaces/IOtoken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IOtoken {\n    function addressBook() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external;\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        );\n\n    function mintOtoken(address account, uint256 amount) external;\n\n    function burnOtoken(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IMarginCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/MarginVault.sol\";\n\ninterface IMarginCalculator {\n    function addressBook() external view returns (address);\n\n    function getExpiredPayoutRate(address _otoken)\n        external\n        view\n        returns (uint256);\n\n    function getExcessCollateral(\n        MarginVault.Vault calldata _vault,\n        uint256 _vaultType\n    ) external view returns (uint256 netValue, bool isExcess);\n\n    function isLiquidatable(\n        MarginVault.Vault memory _vault,\n        uint256 _vaultType,\n        uint256 _vaultLatestUpdate,\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IOracle {\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (bool);\n\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (bool);\n\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp)\n        external\n        view\n        returns (uint256, bool);\n\n    function getDisputer() external view returns (address);\n\n    function getPricer(address _asset) external view returns (address);\n\n    function getPrice(address _asset) external view returns (uint256);\n\n    function getPricerLockingPeriod(address _pricer)\n        external\n        view\n        returns (uint256);\n\n    function getPricerDisputePeriod(address _pricer)\n        external\n        view\n        returns (uint256);\n\n    function getChainlinkRoundData(address _asset, uint80 _roundId)\n        external\n        view\n        returns (uint256, uint256);\n\n    // Non-view function\n\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external;\n\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external;\n\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function setDisputer(address _disputer) external;\n}\n"
    },
    "contracts/interfaces/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IWhitelist {\n    /// @notice emits an event a product is whitelisted by the owner address\n    event ProductWhitelisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event a product is blacklisted by the owner address\n    event ProductBlacklisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event when a collateral address is whitelisted by the owner address\n    event CollateralWhitelisted(address indexed collateral);\n    /// @notice emits an event when a collateral address is blacklist by the owner address\n    event CollateralBlacklisted(address indexed collateral);\n    /// @notice emits an event when an oToken is whitelisted by the OtokenFactory module\n    event OtokenWhitelisted(address indexed otoken);\n    /// @notice emits an event when an oToken is blacklisted by the OtokenFactory module\n    event OtokenBlacklisted(address indexed otoken);\n    /// @notice emits an event when a callee address is whitelisted by the owner address\n    event CalleeWhitelisted(address indexed _callee);\n    /// @notice emits an event when a callee address is blacklisted by the owner address\n    event CalleeBlacklisted(address indexed _callee);\n\n    function addressBook() external view returns (address);\n\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool);\n\n    function isWhitelistedCollateral(address _collateral)\n        external\n        view\n        returns (bool);\n\n    function isWhitelistedOtoken(address _otoken) external view returns (bool);\n\n    function isWhitelistedCallee(address _callee) external view returns (bool);\n\n    /* Admin / factory only functions */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external;\n\n    function whitelistCollateral(address _collateral) external;\n\n    function blacklistCollateral(address _collateral) external;\n\n    function whitelistOtoken(address _otoken) external;\n\n    function blacklistOtoken(address _otoken) external;\n\n    function whitelistCallee(address _callee) external;\n\n    function blacklistCallee(address _callee) external;\n}\n"
    },
    "contracts/interfaces/IMarginPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMarginPool {\n    /// @notice emits an event when marginpool receive funds from controller\n    event TransferToPool(\n        address indexed asset,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emits an event when marginpool transfer funds to controller\n    event TransferToUser(\n        address indexed asset,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emit event after updating the farmer address\n    event FarmerUpdated(address indexed oldAddress, address indexed newAddress);\n    /// @notice emit event when an asset gets harvested from the pool\n    event AssetFarmed(\n        address indexed asset,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /* Getters */\n    function addressBook() external view returns (address);\n\n    function farmer() external view returns (address);\n\n    function getStoredBalance(address _asset) external view returns (uint256);\n\n    /* Admin-only functions */\n    function setFarmer(address _farmer) external;\n\n    function farm(\n        address _asset,\n        address _receiver,\n        uint256 _amount\n    ) external;\n\n    /* Controller-only functions */\n    function transferToPool(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function transferToUser(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) external;\n\n    function batchTransferToPool(\n        address[] calldata _asset,\n        address[] calldata _user,\n        uint256[] calldata _amount\n    ) external;\n\n    function batchTransferToUser(\n        address[] calldata _asset,\n        address[] calldata _user,\n        uint256[] calldata _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/CalleeInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Contract interface that can be called from Controller as a call action.\n */\ninterface CalleeInterface {\n    /**\n     * Allows users to send this contract arbitrary data.\n     * @param _sender The msg.sender to Controller\n     * @param _data Arbitrary data given by the sender\n     */\n    function callFunction(address payable _sender, bytes memory _data) external;\n}\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n    /// @notice emits an event when an account operator is updated for a specific account owner\n    event AccountOperatorUpdated(\n        address indexed accountOwner,\n        address indexed operator,\n        bool isSet\n    );\n    /// @notice emits an event when a new vault is opened\n    event VaultOpened(\n        address indexed accountOwner,\n        uint256 vaultId,\n        uint256 indexed vaultType\n    );\n    /// @notice emits an event when a long oToken is deposited into a vault\n    event LongOtokenDeposited(\n        address indexed otoken,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a long oToken is withdrawn from a vault\n    event LongOtokenWithdrawed(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is deposited into a vault\n    event CollateralAssetDeposited(\n        address indexed asset,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is withdrawn from a vault\n    event CollateralAssetWithdrawed(\n        address indexed asset,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is minted from a vault\n    event ShortOtokenMinted(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is burned\n    event ShortOtokenBurned(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when an oToken is redeemed\n    event Redeem(\n        address indexed otoken,\n        address indexed redeemer,\n        address indexed receiver,\n        address collateralAsset,\n        uint256 otokenBurned,\n        uint256 payout\n    );\n    /// @notice emits an event when a vault is settled\n    event VaultSettled(\n        address indexed accountOwner,\n        address indexed oTokenAddress,\n        address to,\n        uint256 payout,\n        uint256 vaultId,\n        uint256 indexed vaultType\n    );\n    /// @notice emits an event when a vault is liquidated\n    event VaultLiquidated(\n        address indexed liquidator,\n        address indexed receiver,\n        address indexed vaultOwner,\n        uint256 auctionPrice,\n        uint256 auctionStartingRound,\n        uint256 collateralPayout,\n        uint256 debtAmount,\n        uint256 vaultId\n    );\n    /// @notice emits an event when a call action is executed\n    event CallExecuted(address indexed from, address indexed to, bytes data);\n    /// @notice emits an event when the fullPauser address changes\n    event FullPauserUpdated(\n        address indexed oldFullPauser,\n        address indexed newFullPauser\n    );\n    /// @notice emits an event when the partialPauser address changes\n    event PartialPauserUpdated(\n        address indexed oldPartialPauser,\n        address indexed newPartialPauser\n    );\n    /// @notice emits an event when the system partial paused status changes\n    event SystemPartiallyPaused(bool isPaused);\n    /// @notice emits an event when the system fully paused status changes\n    event SystemFullyPaused(bool isPaused);\n    /// @notice emits an event when the call action restriction changes\n    event CallRestricted(bool isRestricted);\n    /// @notice emits an event when a donation transfer executed\n    event Donated(\n        address indexed donator,\n        address indexed asset,\n        uint256 amount\n    );\n    /// @notice emits an event when naked cap is updated\n    event NakedCapUpdated(address indexed collateral, uint256 cap);\n}\n"
    },
    "contracts/libs/MarginVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * MarginVault Error Codes\n * V1: invalid short otoken amount\n * V2: invalid short otoken index\n * V3: short otoken address mismatch\n * V4: invalid long otoken amount\n * V5: invalid long otoken index\n * V6: long otoken address mismatch\n * V7: invalid collateral amount\n * V8: invalid collateral token index\n * V9: collateral token address mismatch\n */\n\n/**\n * @title MarginVault\n * @author Opyn Team\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\n */\nlibrary MarginVault {\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n\n    /**\n     * @dev increase the short oToken balance in a vault when a new oToken is minted\n     * @param _vault vault to add or increase the short position in\n     * @param _shortOtoken address of the _shortOtoken being minted from the user's vault\n     * @param _amount number of _shortOtoken being minted from the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function addShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V1\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if (\n            (_index == _vault.shortOtokens.length) &&\n            (_index == _vault.shortAmounts.length)\n        ) {\n            _vault.shortOtokens.push(_shortOtoken);\n            _vault.shortAmounts.push(_amount);\n        } else {\n            require(\n                (_index < _vault.shortOtokens.length) &&\n                    (_index < _vault.shortAmounts.length),\n                \"V2\"\n            );\n            address existingShort = _vault.shortOtokens[_index];\n            require(\n                (existingShort == _shortOtoken) ||\n                    (existingShort == address(0)),\n                \"V3\"\n            );\n\n            _vault.shortAmounts[_index] += _amount;\n            _vault.shortOtokens[_index] = _shortOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the short oToken balance in a vault when an oToken is burned\n     * @param _vault vault to decrease short position in\n     * @param _shortOtoken address of the _shortOtoken being reduced in the user's vault\n     * @param _amount number of _shortOtoken being reduced in the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function removeShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed short oToken exists in the vault at the specified index\n        require(_index < _vault.shortOtokens.length, \"V2\");\n        require(_vault.shortOtokens[_index] == _shortOtoken, \"V3\");\n\n        uint256 newShortAmount = _vault.shortAmounts[_index] - _amount;\n\n        if (newShortAmount == 0) {\n            delete _vault.shortOtokens[_index];\n        }\n        _vault.shortAmounts[_index] = newShortAmount;\n    }\n\n    /**\n     * @dev increase the long oToken balance in a vault when an oToken is deposited\n     * @param _vault vault to add a long position to\n     * @param _longOtoken address of the _longOtoken being added to the user's vault\n     * @param _amount number of _longOtoken the protocol is adding to the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function addLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V4\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if (\n            (_index == _vault.longOtokens.length) &&\n            (_index == _vault.longAmounts.length)\n        ) {\n            _vault.longOtokens.push(_longOtoken);\n            _vault.longAmounts.push(_amount);\n        } else {\n            require(\n                (_index < _vault.longOtokens.length) &&\n                    (_index < _vault.longAmounts.length),\n                \"V5\"\n            );\n            address existingLong = _vault.longOtokens[_index];\n            require(\n                (existingLong == _longOtoken) || (existingLong == address(0)),\n                \"V6\"\n            );\n\n            _vault.longAmounts[_index] += _amount;\n            _vault.longOtokens[_index] = _longOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the long oToken balance in a vault when an oToken is withdrawn\n     * @param _vault vault to remove a long position from\n     * @param _longOtoken address of the _longOtoken being removed from the user's vault\n     * @param _amount number of _longOtoken the protocol is removing from the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function removeLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed long oToken exists in the vault at the specified index\n        require(_index < _vault.longOtokens.length, \"V5\");\n        require(_vault.longOtokens[_index] == _longOtoken, \"V6\");\n\n        uint256 newLongAmount = _vault.longAmounts[_index] - _amount;\n\n        if (newLongAmount == 0) {\n            delete _vault.longOtokens[_index];\n        }\n        _vault.longAmounts[_index] = newLongAmount;\n    }\n\n    /**\n     * @dev increase the collateral balance in a vault\n     * @param _vault vault to add collateral to\n     * @param _collateralAsset address of the _collateralAsset being added to the user's vault\n     * @param _amount number of _collateralAsset being added to the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function addCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V7\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if (\n            (_index == _vault.collateralAssets.length) &&\n            (_index == _vault.collateralAmounts.length)\n        ) {\n            _vault.collateralAssets.push(_collateralAsset);\n            _vault.collateralAmounts.push(_amount);\n        } else {\n            require(\n                (_index < _vault.collateralAssets.length) &&\n                    (_index < _vault.collateralAmounts.length),\n                \"V8\"\n            );\n            address existingCollateral = _vault.collateralAssets[_index];\n            require(\n                (existingCollateral == _collateralAsset) ||\n                    (existingCollateral == address(0)),\n                \"V9\"\n            );\n\n            _vault.collateralAmounts[_index] += _amount;\n            _vault.collateralAssets[_index] = _collateralAsset;\n        }\n    }\n\n    /**\n     * @dev decrease the collateral balance in a vault\n     * @param _vault vault to remove collateral from\n     * @param _collateralAsset address of the _collateralAsset being removed from the user's vault\n     * @param _amount number of _collateralAsset being removed from the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function removeCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed collateral exists in the vault at the specified index\n        require(_index < _vault.collateralAssets.length, \"V8\");\n        require(_vault.collateralAssets[_index] == _collateralAsset, \"V9\");\n\n        uint256 newCollateralAmount = _vault.collateralAmounts[_index] -\n            _amount;\n\n        if (newCollateralAmount == 0) {\n            delete _vault.collateralAssets[_index];\n        }\n        _vault.collateralAmounts[_index] = newCollateralAmount;\n    }\n}\n"
    },
    "contracts/libs/Actions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./MarginVault.sol\";\n\n/**\n * @title Actions\n * @author Opyn Team\n * @notice A library that provides a ActionArgs struct, sub types of Action structs, and functions to parse ActionArgs into specific Actions.\n * errorCode\n * A1 can only parse arguments for open vault actions\n * A2 cannot open vault for an invalid account\n * A3 cannot open vault with an invalid type\n * A4 can only parse arguments for mint actions\n * A5 cannot mint from an invalid account\n * A6 can only parse arguments for burn actions\n * A7 cannot burn from an invalid account\n * A8 can only parse arguments for deposit actions\n * A9 cannot deposit to an invalid account\n * A10 can only parse arguments for withdraw actions\n * A11 cannot withdraw from an invalid account\n * A12 cannot withdraw to an invalid account\n * A13 can only parse arguments for redeem actions\n * A14 cannot redeem to an invalid account\n * A15 can only parse arguments for settle vault actions\n * A16 cannot settle vault for an invalid account\n * A17 cannot withdraw payout to an invalid account\n * A18 can only parse arguments for liquidate action\n * A19 cannot liquidate vault for an invalid account owner\n * A20 cannot send collateral to an invalid account\n * A21 cannot parse liquidate action with no round id\n * A22 can only parse arguments for call actions\n * A23 target address cannot be address(0)\n */\nlibrary Actions {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call,\n        Liquidate\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct MintArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the asset will be minted\n        uint256 vaultId;\n        // address to which we transfer the minted oTokens\n        address to;\n        // oToken that is to be minted\n        address otoken;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of oTokens that is to be minted\n        uint256 amount;\n    }\n\n    struct BurnArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the oToken will be burned\n        uint256 vaultId;\n        // address from which we transfer the oTokens\n        address from;\n        // oToken that is to be burned\n        address otoken;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of oTokens that is to be burned\n        uint256 amount;\n    }\n\n    struct OpenVaultArgs {\n        // address of the account owner\n        address owner;\n        // vault id to create\n        uint256 vaultId;\n        // vault type, 0 for spread/max loss and 1 for naked margin vault\n        uint256 vaultType;\n    }\n\n    struct DepositArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault to which the asset will be added\n        uint256 vaultId;\n        // address from which we transfer the asset\n        address from;\n        // asset that is to be deposited\n        address asset;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of asset that is to be deposited\n        uint256 amount;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    struct WithdrawArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault from which the asset will be withdrawn\n        uint256 vaultId;\n        // address to which we transfer the asset\n        address to;\n        // asset that is to be withdrawn\n        address asset;\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // amount of asset that is to be withdrawn\n        uint256 amount;\n    }\n\n    struct SettleVaultArgs {\n        // address of the account owner\n        address owner;\n        // index of the vault to which is to be settled\n        uint256 vaultId;\n        // address to which we transfer the remaining collateral\n        address to;\n    }\n\n    struct LiquidateArgs {\n        // address of the vault owner to liquidate\n        address owner;\n        // address of the liquidated collateral receiver\n        address receiver;\n        // vault id to liquidate\n        uint256 vaultId;\n        // amount of debt(otoken) to repay\n        uint256 amount;\n        // chainlink round id\n        uint256 roundId;\n    }\n\n    struct CallArgs {\n        // address of the callee contract\n        address callee;\n        // data field for external calls\n        bytes data;\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for an open vault action\n     * @param _args general action arguments structure\n     * @return arguments for a open vault action\n     */\n    function _parseOpenVaultArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (OpenVaultArgs memory)\n    {\n        require(_args.actionType == ActionType.OpenVault, \"A1\");\n        require(_args.owner != address(0), \"A2\");\n\n        // if not _args.data included, vault type will be 0 by default\n        uint256 vaultType;\n\n        if (_args.data.length == 32) {\n            // decode vault type from _args.data\n            vaultType = abi.decode(_args.data, (uint256));\n        }\n\n        // for now we only have 2 vault types\n        require(vaultType < 2, \"A3\");\n\n        return\n            OpenVaultArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                vaultType: vaultType\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a mint action\n     * @param _args general action arguments structure\n     * @return arguments for a mint action\n     */\n    function _parseMintArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (MintArgs memory)\n    {\n        require(_args.actionType == ActionType.MintShortOption, \"A4\");\n        require(_args.owner != address(0), \"A5\");\n\n        return\n            MintArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                to: _args.secondAddress,\n                otoken: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a burn action\n     * @param _args general action arguments structure\n     * @return arguments for a burn action\n     */\n    function _parseBurnArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (BurnArgs memory)\n    {\n        require(_args.actionType == ActionType.BurnShortOption, \"A6\");\n        require(_args.owner != address(0), \"A7\");\n\n        return\n            BurnArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                from: _args.secondAddress,\n                otoken: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a deposit action\n     * @param _args general action arguments structure\n     * @return arguments for a deposit action\n     */\n    function _parseDepositArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (DepositArgs memory)\n    {\n        require(\n            (_args.actionType == ActionType.DepositLongOption) ||\n                (_args.actionType == ActionType.DepositCollateral),\n            \"A8\"\n        );\n        require(_args.owner != address(0), \"A9\");\n\n        return\n            DepositArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                from: _args.secondAddress,\n                asset: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a withdraw action\n     * @param _args general action arguments structure\n     * @return arguments for a withdraw action\n     */\n    function _parseWithdrawArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (WithdrawArgs memory)\n    {\n        require(\n            (_args.actionType == ActionType.WithdrawLongOption) ||\n                (_args.actionType == ActionType.WithdrawCollateral),\n            \"A10\"\n        );\n        require(_args.owner != address(0), \"A11\");\n        require(_args.secondAddress != address(0), \"A12\");\n\n        return\n            WithdrawArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                to: _args.secondAddress,\n                asset: _args.asset,\n                index: _args.index,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for an redeem action\n     * @param _args general action arguments structure\n     * @return arguments for a redeem action\n     */\n    function _parseRedeemArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (RedeemArgs memory)\n    {\n        require(_args.actionType == ActionType.Redeem, \"A13\");\n        require(_args.secondAddress != address(0), \"A14\");\n\n        return\n            RedeemArgs({\n                receiver: _args.secondAddress,\n                otoken: _args.asset,\n                amount: _args.amount\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a settle vault action\n     * @param _args general action arguments structure\n     * @return arguments for a settle vault action\n     */\n    function _parseSettleVaultArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (SettleVaultArgs memory)\n    {\n        require(_args.actionType == ActionType.SettleVault, \"A15\");\n        require(_args.owner != address(0), \"A16\");\n        require(_args.secondAddress != address(0), \"A17\");\n\n        return\n            SettleVaultArgs({\n                owner: _args.owner,\n                vaultId: _args.vaultId,\n                to: _args.secondAddress\n            });\n    }\n\n    function _parseLiquidateArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (LiquidateArgs memory)\n    {\n        require(_args.actionType == ActionType.Liquidate, \"A18\");\n        require(_args.owner != address(0), \"A19\");\n        require(_args.secondAddress != address(0), \"A20\");\n        require(_args.data.length == 32, \"A21\");\n\n        // decode chainlink round id from _args.data\n        uint256 roundId = abi.decode(_args.data, (uint256));\n\n        return\n            LiquidateArgs({\n                owner: _args.owner,\n                receiver: _args.secondAddress,\n                vaultId: _args.vaultId,\n                amount: _args.amount,\n                roundId: roundId\n            });\n    }\n\n    /**\n     * @notice parses the passed in action arguments to get the arguments for a call action\n     * @param _args general action arguments structure\n     * @return arguments for a call action\n     */\n    function _parseCallArgs(ActionArgs memory _args)\n        internal\n        pure\n        returns (CallArgs memory)\n    {\n        require(_args.actionType == ActionType.Call, \"A22\");\n        require(_args.secondAddress != address(0), \"A23\");\n\n        return CallArgs({callee: _args.secondAddress, data: _args.data});\n    }\n}\n"
    },
    "contracts/MarginPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IAddressBook.sol\";\nimport \"./interfaces/IMarginPool.sol\";\n\n/**\n * @author Opyn Team\n * @title MarginPool\n * @notice Contract that holds all protocol funds\n */\ncontract MarginPool is IMarginPool, Ownable {\n    using SafeERC20 for IERC20;\n\n    /// @notice AddressBook module\n    address public override addressBook;\n    /// @dev the address that has the ability to withdraw excess assets in the pool\n    address public override farmer;\n    /// @dev mapping between an asset and the amount of the asset in the pool\n    mapping(address => uint256) internal assetBalance;\n\n    /**\n     * @notice contructor\n     * @param _addressBook AddressBook module\n     */\n    constructor(address _addressBook) {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /**\n     * @notice check if the sender is the Controller module\n     */\n    modifier onlyController() {\n        require(\n            msg.sender == IAddressBook(addressBook).getController(),\n            \"MarginPool: Sender is not Controller\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if the sender is the farmer address\n     */\n    modifier onlyFarmer() {\n        require(msg.sender == farmer, \"MarginPool: Sender is not farmer\");\n\n        _;\n    }\n\n    /**\n     * @notice transfers an asset from a user to the pool\n     * @param _asset address of the asset to transfer\n     * @param _user address of the user to transfer assets from\n     * @param _amount amount of the token to transfer from _user\n     */\n    function transferToPool(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) public override onlyController {\n        require(_amount > 0, \"MarginPool: transferToPool amount is equal to 0\");\n        assetBalance[_asset] += _amount;\n\n        // transfer _asset _amount from _user to pool\n        IERC20(_asset).safeTransferFrom(_user, address(this), _amount);\n        emit TransferToPool(_asset, _user, _amount);\n    }\n\n    /**\n     * @notice transfers an asset from the pool to a user\n     * @param _asset address of the asset to transfer\n     * @param _user address of the user to transfer assets to\n     * @param _amount amount of the token to transfer to _user\n     */\n    function transferToUser(\n        address _asset,\n        address _user,\n        uint256 _amount\n    ) public override onlyController {\n        require(\n            _user != address(this),\n            \"MarginPool: cannot transfer assets to oneself\"\n        );\n        assetBalance[_asset] -= _amount;\n\n        // transfer _asset _amount from pool to _user\n        IERC20(_asset).safeTransfer(_user, _amount);\n        emit TransferToUser(_asset, _user, _amount);\n    }\n\n    /**\n     * @notice get the stored balance of an asset\n     * @param _asset asset address\n     * @return asset balance\n     */\n    function getStoredBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return assetBalance[_asset];\n    }\n\n    /**\n     * @notice transfers multiple assets from users to the pool\n     * @param _asset addresses of the assets to transfer\n     * @param _user addresses of the users to transfer assets to\n     * @param _amount amount of each token to transfer to pool\n     */\n    function batchTransferToPool(\n        address[] memory _asset,\n        address[] memory _user,\n        uint256[] memory _amount\n    ) external override onlyController {\n        require(\n            _asset.length == _user.length && _user.length == _amount.length,\n            \"MarginPool: batchTransferToPool array lengths are not equal\"\n        );\n\n        for (uint256 i = 0; i < _asset.length; i++) {\n            // transfer _asset _amount from _user to pool\n            transferToPool(_asset[i], _user[i], _amount[i]);\n        }\n    }\n\n    /**\n     * @notice transfers multiple assets from the pool to users\n     * @param _asset addresses of the assets to transfer\n     * @param _user addresses of the users to transfer assets to\n     * @param _amount amount of each token to transfer to _user\n     */\n    function batchTransferToUser(\n        address[] memory _asset,\n        address[] memory _user,\n        uint256[] memory _amount\n    ) external override onlyController {\n        require(\n            _asset.length == _user.length && _user.length == _amount.length,\n            \"MarginPool: batchTransferToUser array lengths are not equal\"\n        );\n\n        for (uint256 i = 0; i < _asset.length; i++) {\n            // transfer _asset _amount from pool to _user\n            transferToUser(_asset[i], _user[i], _amount[i]);\n        }\n    }\n\n    /**\n     * @notice function to collect the excess balance of a particular asset\n     * @dev can only be called by the farmer address. Do not farm otokens.\n     * @param _asset asset address\n     * @param _receiver receiver address\n     * @param _amount amount to remove from pool\n     */\n    function farm(\n        address _asset,\n        address _receiver,\n        uint256 _amount\n    ) external override onlyFarmer {\n        require(\n            _receiver != address(0),\n            \"MarginPool: invalid receiver address\"\n        );\n\n        uint256 externalBalance = IERC20(_asset).balanceOf(address(this));\n        uint256 storedBalance = assetBalance[_asset];\n\n        require(\n            _amount <= externalBalance - storedBalance,\n            \"MarginPool: amount to farm exceeds limit\"\n        );\n\n        IERC20(_asset).safeTransfer(_receiver, _amount);\n\n        emit AssetFarmed(_asset, _receiver, _amount);\n    }\n\n    /**\n     * @notice function to set farmer address\n     * @dev can only be called by MarginPool owner\n     * @param _farmer farmer address\n     */\n    function setFarmer(address _farmer) external override onlyOwner {\n        emit FarmerUpdated(farmer, _farmer);\n\n        farmer = _farmer;\n    }\n}\n"
    },
    "contracts/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interfaces/IAddressBook.sol\";\r\nimport \"./interfaces/IWhitelist.sol\";\r\n\r\n/**\r\n * @author Opyn Team\r\n * @title Whitelist Module\r\n * @notice The whitelist module keeps track of all valid oToken addresses, product hashes, collateral addresses, and callee addresses.\r\n */\r\ncontract Whitelist is IWhitelist, Ownable {\r\n    /// @notice AddressBook module address\r\n    address public addressBook;\r\n    /// @dev mapping to track whitelisted products\r\n    mapping(bytes32 => bool) internal whitelistedProduct;\r\n    /// @dev mapping to track whitelisted collateral\r\n    mapping(address => bool) internal whitelistedCollateral;\r\n    /// @dev mapping to track whitelisted oTokens\r\n    mapping(address => bool) internal whitelistedOtoken;\r\n    /// @dev mapping to track whitelisted callee addresses for the call action\r\n    mapping(address => bool) internal whitelistedCallee;\r\n\r\n    /**\r\n     * @dev constructor\r\n     * @param _addressBook AddressBook module address\r\n     */\r\n    constructor(address _addressBook) {\r\n        require(_addressBook != address(0), \"Invalid address book\");\r\n\r\n        addressBook = _addressBook;\r\n    }\r\n\r\n    /**\r\n     * @notice check if the sender is the oTokenFactory module\r\n     */\r\n    modifier onlyFactory() {\r\n        require(\r\n            msg.sender == IAddressBook(addressBook).getOtokenFactory(),\r\n            \"Whitelist: Sender is not OtokenFactory\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice check if a product is whitelisted\r\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\r\n     * @param _underlying asset that the option references\r\n     * @param _strike asset that the strike price is denominated in\r\n     * @param _collateral asset that is held as collateral against short/written options\r\n     * @param _isPut True if a put option, False if a call option\r\n     * @return boolean, True if product is whitelisted\r\n     */\r\n    function isWhitelistedProduct(\r\n        address _underlying,\r\n        address _strike,\r\n        address _collateral,\r\n        bool _isPut\r\n    ) external view returns (bool) {\r\n        bytes32 productHash = keccak256(\r\n            abi.encode(_underlying, _strike, _collateral, _isPut)\r\n        );\r\n\r\n        return whitelistedProduct[productHash];\r\n    }\r\n\r\n    /**\r\n     * @notice check if a collateral asset is whitelisted\r\n     * @param _collateral asset that is held as collateral against short/written options\r\n     * @return boolean, True if the collateral is whitelisted\r\n     */\r\n    function isWhitelistedCollateral(address _collateral)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return whitelistedCollateral[_collateral];\r\n    }\r\n\r\n    /**\r\n     * @notice check if an oToken is whitelisted\r\n     * @param _otoken oToken address\r\n     * @return boolean, True if the oToken is whitelisted\r\n     */\r\n    function isWhitelistedOtoken(address _otoken) external view returns (bool) {\r\n        return whitelistedOtoken[_otoken];\r\n    }\r\n\r\n    /**\r\n     * @notice check if a callee address is whitelisted for the call action\r\n     * @param _callee callee destination address\r\n     * @return boolean, True if the address is whitelisted\r\n     */\r\n    function isWhitelistedCallee(address _callee) external view returns (bool) {\r\n        return whitelistedCallee[_callee];\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to whitelist a product\r\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\r\n     * can only be called from the owner address\r\n     * @param _underlying asset that the option references\r\n     * @param _strike asset that the strike price is denominated in\r\n     * @param _collateral asset that is held as collateral against short/written options\r\n     * @param _isPut True if a put option, False if a call option\r\n     */\r\n    function whitelistProduct(\r\n        address _underlying,\r\n        address _strike,\r\n        address _collateral,\r\n        bool _isPut\r\n    ) external onlyOwner {\r\n        require(\r\n            whitelistedCollateral[_collateral],\r\n            \"Whitelist: Collateral is not whitelisted\"\r\n        );\r\n        require(\r\n            (_isPut && (_strike == _collateral)) ||\r\n                (!_isPut && (_collateral == _underlying)),\r\n            \"Whitelist: Only allow fully collateralized products\"\r\n        );\r\n\r\n        bytes32 productHash = keccak256(\r\n            abi.encode(_underlying, _strike, _collateral, _isPut)\r\n        );\r\n\r\n        whitelistedProduct[productHash] = true;\r\n\r\n        emit ProductWhitelisted(\r\n            productHash,\r\n            _underlying,\r\n            _strike,\r\n            _collateral,\r\n            _isPut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice allow the owner to blacklist a product\r\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\r\n     * can only be called from the owner address\r\n     * @param _underlying asset that the option references\r\n     * @param _strike asset that the strike price is denominated in\r\n     * @param _collateral asset that is held as collateral against short/written options\r\n     * @param _isPut True if a put option, False if a call option\r\n     */\r\n    function blacklistProduct(\r\n        address _underlying,\r\n        address _strike,\r\n        address _collateral,\r\n        bool _isPut\r\n    ) external onlyOwner {\r\n        bytes32 productHash = keccak256(\r\n            abi.encode(_underlying, _strike, _collateral, _isPut)\r\n        );\r\n\r\n        whitelistedProduct[productHash] = false;\r\n\r\n        emit ProductBlacklisted(\r\n            productHash,\r\n            _underlying,\r\n            _strike,\r\n            _collateral,\r\n            _isPut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to whitelist a collateral address\r\n     * @dev can only be called from the owner address. This function is used to whitelist any asset other than Otoken as collateral. WhitelistOtoken() is used to whitelist Otoken contracts.\r\n     * @param _collateral collateral asset address\r\n     */\r\n    function whitelistCollateral(address _collateral) external onlyOwner {\r\n        whitelistedCollateral[_collateral] = true;\r\n\r\n        emit CollateralWhitelisted(_collateral);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to blacklist a collateral address\r\n     * @dev can only be called from the owner address\r\n     * @param _collateral collateral asset address\r\n     */\r\n    function blacklistCollateral(address _collateral) external onlyOwner {\r\n        whitelistedCollateral[_collateral] = false;\r\n\r\n        emit CollateralBlacklisted(_collateral);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the OtokenFactory module to whitelist a new option\r\n     * @dev can only be called from the OtokenFactory address\r\n     * @param _otokenAddress oToken\r\n     */\r\n    function whitelistOtoken(address _otokenAddress) external onlyFactory {\r\n        whitelistedOtoken[_otokenAddress] = true;\r\n\r\n        emit OtokenWhitelisted(_otokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to blacklist an option\r\n     * @dev can only be called from the owner address\r\n     * @param _otokenAddress oToken\r\n     */\r\n    function blacklistOtoken(address _otokenAddress) external onlyOwner {\r\n        whitelistedOtoken[_otokenAddress] = false;\r\n\r\n        emit OtokenBlacklisted(_otokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to whitelist a destination address for the call action\r\n     * @dev can only be called from the owner address\r\n     * @param _callee callee address\r\n     */\r\n    function whitelistCallee(address _callee) external onlyOwner {\r\n        whitelistedCallee[_callee] = true;\r\n\r\n        emit CalleeWhitelisted(_callee);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to blacklist a destination address for the call action\r\n     * @dev can only be called from the owner address\r\n     * @param _callee callee address\r\n     */\r\n    function blacklistCallee(address _callee) external onlyOwner {\r\n        whitelistedCallee[_callee] = false;\r\n\r\n        emit CalleeBlacklisted(_callee);\r\n    }\r\n}\r\n"
    },
    "contracts/OtokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/IOtoken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\nimport \"./interfaces/IAddressBook.sol\";\nimport \"./interfaces/IOtokenFactory.sol\";\nimport \"./utils/OtokenSpawner.sol\";\n\n/**\n * @title A factory to create Opyn oTokens\n * @author Opyn Team\n * @notice Create new oTokens and keep track of all created tokens\n * @dev Calculate contract address before each creation with CREATE2\n * and deploy eip-1167 minimal proxies for oToken logic contract\n */\ncontract OtokenFactory is IOtokenFactory, OtokenSpawner {\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\n    address public override addressBook;\n\n    /// @notice array of all created otokens */\n    address[] public otokens;\n\n    /// @dev mapping from parameters hash to its deployed address\n    mapping(bytes32 => address) private idToAddress;\n\n    /// @dev max expiry that BokkyPooBahsDateTimeLibrary can handle. (2345/12/31)\n    uint256 private constant MAX_EXPIRY = 11865398400;\n\n    constructor(address _addressBook) {\n        addressBook = _addressBook;\n    }\n\n    /**\n     * @notice create new oTokens\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return newOtoken address of the newly created option\n     */\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external override returns (address) {\n        require(\n            _expiry > block.timestamp,\n            \"OtokenFactory: Can't create expired option\"\n        );\n        require(\n            _expiry < MAX_EXPIRY,\n            \"OtokenFactory: Can't create option with expiry > 2345/12/31\"\n        );\n        // 8 hours = 3600 * 8 = 28800 seconds\n        require(\n            (_expiry - 28800) % 86400 == 0,\n            \"OtokenFactory: Option has to expire 08:00 UTC\"\n        );\n        bytes32 id = _getOptionId(\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        require(\n            idToAddress[id] == address(0),\n            \"OtokenFactory: Option already created\"\n        );\n\n        address whitelist = IAddressBook(addressBook).getWhitelist();\n        require(\n            IWhitelist(whitelist).isWhitelistedProduct(\n                _underlyingAsset,\n                _strikeAsset,\n                _collateralAsset,\n                _isPut\n            ),\n            \"OtokenFactory: Unsupported Product\"\n        );\n\n        require(\n            !_isPut || _strikePrice > 0,\n            \"OtokenFactory: Can't create a $0 strike put option\"\n        );\n\n        address otokenImpl = IAddressBook(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            IOtoken(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\n\n        idToAddress[id] = newOtoken;\n        otokens.push(newOtoken);\n        IWhitelist(whitelist).whitelistOtoken(newOtoken);\n\n        emit OtokenCreated(\n            newOtoken,\n            msg.sender,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        return newOtoken;\n    }\n\n    /**\n     * @notice get the total oTokens created by the factory\n     * @return length of the oTokens array\n     */\n    function getOtokensLength() external view returns (uint256) {\n        return otokens.length;\n    }\n\n    /**\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return the address of target otoken.\n     */\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        bytes32 id = _getOptionId(\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return idToAddress[id];\n    }\n\n    /**\n     * @notice get the address at which a new oToken with these parameters would be deployed\n     * @dev return the exact address that will be deployed at with _computeAddress\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return targetAddress the address this oToken would be deployed at\n     */\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        address otokenImpl = IAddressBook(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            IOtoken(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return _computeAddress(otokenImpl, initializationCalldata);\n    }\n\n    /**\n     * @dev hash oToken parameters and return a unique option id\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return id the unique id of an oToken\n     */\n    function _getOptionId(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _underlyingAsset,\n                    _strikeAsset,\n                    _collateralAsset,\n                    _strikePrice,\n                    _expiry,\n                    _isPut\n                )\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IOtokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IOtokenFactory {\r\n    /// @notice emitted when the factory creates a new Option\r\n    event OtokenCreated(\r\n        address tokenAddress,\r\n        address creator,\r\n        address indexed underlying,\r\n        address indexed strike,\r\n        address indexed collateral,\r\n        uint256 strikePrice,\r\n        uint256 expiry,\r\n        bool isPut\r\n    );\r\n\r\n    function addressBook() external view returns (address);\r\n\r\n    function createOtoken(\r\n        address _underlyingAsset,\r\n        address _strikeAsset,\r\n        address _collateralAsset,\r\n        uint256 _strikePrice,\r\n        uint256 _expiry,\r\n        bool _isPut\r\n    ) external returns (address);\r\n}\r\n"
    },
    "contracts/utils/OtokenSpawner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"./Spawn.sol\";\n\n/**\n * @title OtokenSpawner\n * @author Opyn Team\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts.\n * @notice This contract was modified from Spawner.sol\n * https://github.com/0age/Spawner/blob/master/contracts/Spawner.sol to fit into OtokenFactory\n */\nabstract contract OtokenSpawner {\n    // fixed salt value because we will only deploy an oToken with the same init value once\n    bytes32 private constant SALT = bytes32(0);\n\n    /**\n     * @notice internal function for spawning an eip-1167 minimal proxy using `CREATE2`\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return spawnedContract the address of the newly-spawned contract\n     */\n    function _spawn(address logicContract, bytes memory initializationCalldata)\n        internal\n        returns (address)\n    {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n\n        // spawn the contract using `CREATE2`\n        return Create2.deploy(0, SALT, initCode);\n    }\n\n    /**\n     * @notice internal view function for finding the address of the standard\n     * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n     * and initialization calldata payload\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return target address of the next spawned minimal proxy contract with the\n     * given parameters.\n     */\n    function _computeAddress(\n        address logicContract,\n        bytes memory initializationCalldata\n    ) internal view returns (address target) {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n        // get target address using the constructed initialization code\n        bytes32 initCodeHash = keccak256(initCode);\n\n        target = Create2.computeAddress(SALT, initCodeHash);\n    }\n}\n"
    },
    "contracts/utils/Spawn.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n */\n// version: https://github.com/0age/Spawner/blob/1b342afda0c1ec47e6a2d65828a6ca50f0a442fe/contracts/Spawner.sol\ncontract Spawn {\n    constructor(address logicContract, bytes memory initializationCalldata)\n        payable\n    {\n        // delegatecall into the logic contract to perform initialization.\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n        if (!ok) {\n            // pass along failure message from delegatecall and revert.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode = abi.encodePacked(\n            bytes10(0x363d3d373d3d3d363d73),\n            logicContract,\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\n        );\n\n        // return eip-1167 code to write it to spawned contract runtime.\n        assembly {\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "contracts/Otoken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./utils/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./interfaces/IAddressBook.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Upgradeable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20PermitUpgradeable {\n    /// @notice address of the Controller module\n    address public controller;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _addressBook addressbook module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        controller = IAddressBook(_addressBook).getController();\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (\n            string memory tokenName,\n            string memory tokenSymbol\n        ) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        __ERC20Permit_init(tokenName);\n    }\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            collateralAsset,\n            underlyingAsset,\n            strikeAsset,\n            strikePrice,\n            expiryTimestamp,\n            isPut\n        );\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == controller,\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == controller,\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol()\n        internal\n        view\n        returns (string memory tokenName, string memory tokenSymbol)\n    {\n        string memory underlying = ERC20Upgradeable(underlyingAsset).symbol();\n        string memory strike = ERC20Upgradeable(strikeAsset).symbol();\n        string memory collateral = ERC20Upgradeable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(\n            strikePrice\n        );\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\n        .timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(\n            isPut\n        );\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC/USDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"/\",\n                collateral,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice)\n        internal\n        pure\n        returns (string memory)\n    {\n        uint256 remainder = _strikePrice % STRIKE_PRICE_SCALE;\n        uint256 quotient = _strikePrice / STRIKE_PRICE_SCALE;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(\n            abi.encodePacked(quotientStr, \".\", tmpStr)\n        );\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut)\n        internal\n        pure\n        returns (string memory shortString, string memory longString)\n    {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        returns (string memory shortString, string memory longString)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}\n"
    },
    "contracts/utils/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n// version v1.01\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/tokens/TestingWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract TestingWETH is ERC20 {\r\n    constructor() ERC20(\"Testing WETH\", \"tWETH\") {\r\n        _mint(msg.sender, 1_000_000_000 * 1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/TestingUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract TestingUSDC is ERC20 {\r\n    constructor() ERC20(\"Testing USDC\", \"tUSDC\") {\r\n        _mint(msg.sender, 1_000_000_000 * 1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/ManualStrikeSelection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ManualStrikeSelection is Ownable {\n    /// @dev Selected strike price\n    uint256 public strikePrice;\n\n    /// @dev Delta for options strike price selection. 1 is 10000 (10**4)\n    uint256 public constant delta = 1000;\n\n    /**\n     * @notice Sets the strike price, only callable by the owner\n     * @param _strikePrice is the strike price of the option\n     */\n    function setStrikePrice(uint256 _strikePrice) external onlyOwner {\n        strikePrice = _strikePrice;\n    }\n\n    /**\n     * @notice Gets the strike price satisfying the delta value\n     * given the expiry timestamp and whether option is call or put\n     * @return newStrikePrice is the strike price of the option (ex: for BTC might be 45000 * 10 ** 8)\n     * @return newDelta is the delta of the option given its parameters\n     */\n    function getStrikePrice(uint256, bool)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return (strikePrice, delta);\n    }\n}\n"
    },
    "contracts/Greeter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract Greeter {\n    string private greeting;\n\n    constructor(string memory _greeting) {\n        console.log(\"Deploying a Greeter with greeting:\", _greeting);\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n\n    function setGreeting(string memory _greeting) public {\n        console.log(\"Changing greeting from '%s' to '%s'\", greeting, _greeting);\n        greeting = _greeting;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/IRibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IRibbonVault {\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n}\n"
    },
    "contracts/utils/TestOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract TestOracle {\r\n    uint256 public answer;\r\n\r\n    constructor(uint256 initAnswer) {\r\n        answer = initAnswer;\r\n    }\r\n\r\n    function setAnswer(uint256 _answer) external {\r\n        answer = _answer;\r\n    }\r\n\r\n    function decimals() external pure returns (uint256) {\r\n        return 8;\r\n    }\r\n\r\n    function latestAnswer() external view returns (uint256) {\r\n        return answer;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/TestVolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract TestVolOracle {\r\n    uint256 public answer;\r\n\r\n    constructor(uint256 initAnswer) {\r\n        answer = initAnswer;\r\n    }\r\n\r\n    function setAnswer(uint256 _answer) external {\r\n        answer = _answer;\r\n    }\r\n\r\n    function decimals() external pure returns (uint256) {\r\n        return 8;\r\n    }\r\n\r\n    function annualizedVol(\r\n        bytes32 /*optionId*/\r\n    ) external view returns (uint256) {\r\n        return answer;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}